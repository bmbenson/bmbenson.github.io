---
layout: post
title: Rust‚Ää‚Äî‚ÄäConway‚Äôs Game of Life in Bevy ECS
tag:
- rustlang
- coding
- games
- bevy
---

<h3>Rust‚Ää‚Äî‚ÄäConway‚Äôs Game of Life in Bevy¬†ECS</h3><h3>Introduction</h3><p>Hey all, this is my first tutorial and medium post. I decided to share a tutorial based on some recent things I learned when working with the Bevy game engine for the Rust programming language.</p><p>For this article I wanted to focus on how we might recreate one of the oldest computer games/simulations out there, called <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Conway‚Äôs Game of Life</a> created in 1969 by John Conway. The simulation is quite basic in that there are only four rules, but create some very interesting patterns, some only showing up/stabilizing after hundreds or thousands of iterations.</p><h3>Prerequisites</h3><p>This tutorial assumes some familiarity with Rust and a working installation of git. If you aren‚Äôt read up, no worries! I have linked some resources to fill in your¬†gaps.</p><ul><li>Installing Rust: <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a></li><li>Installing Git: <a href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git">https://git-scm.com/book/en/v2/Getting-Started-Installing-Git</a></li><li>Using Git: <a href="https://www.codecademy.com/learn/learn-git">https://www.codecademy.com/learn/learn-git</a></li></ul><p>For a Rust editor, I like VSCode these days: <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>‚Ää‚Äî‚Ääwe don‚Äôt cover anything VSCode specific in this tutorial, so use whatever editor suits¬†you.</p><p>Ensure you are on the latest version of cargo and rust‚Ää‚Äî‚Ääto do so, execute rustup update to update your¬†tools.</p><p>Throughout the tutorial I will be including the full main.rs file to resync. If you want to skip ahead, each section generally has a commit message you can find in <a href="https://github.com/bmbenson/bevy-game-of-life">my github repo</a> and using git you can follow along with much less typing + copy/paste.</p><h3>Getting Started‚Ää‚Äî‚ÄäDisplay something</h3><p>In your Rust project workspace initialize the cargo and git workspace:</p><pre>cargo new game-of-life<br>cd game-of-life<br>git init<br>git add .<br>git commit -m &quot;Initial commit of a new cargo binary workspace.&quot;</pre><p><strong>Note: </strong>While we‚Äôre not covering git in this tutorial, I will be injecting reminders to commit the progress from time to¬†time.</p><p>Add bevy to your cargo dependencies cargo add¬†bevy</p><p>The cargo add command automatically added the new bevy dependency to your Cargo.toml file. Open up the file to¬†see.</p><p>Cargo.toml should look¬†like:</p><pre>[package]<br>name = &quot;game-of-life&quot;<br>version = &quot;0.1.0&quot;<br>edition = &quot;2021&quot;<br><br># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html<br><br>[dependencies]<br>bevy = &quot;0.12.1&quot;</pre><p><em>Note: </em>As of the writing of this article, the latest bevy is 0.12.1‚Ää‚Äî‚ÄäIf in the future there is an update that causes this tutorial to be incompatible, please reach out and I will work on making an¬†update!</p><p>In your src/main.rs file, we‚Äôll add the basic bevy app and run it to be sure the dependencies and the cargo workspace are set up properly. Throughout the code blocks I have included #![warn(clippy::pedantic)] which causes the linter to highlight areas of code that do not meet (stringent) best practices, but in some areas the linter suggestions conflict with the methods Bevy uses for passing params into the systems, so you‚Äôll see we disable a few clippy checks where necessary.</p><pre>//main.rs<br>#![warn(clippy::pedantic)]<br><br>use bevy::prelude::*;<br><br>fn main() {<br>    println!(&quot;Bevy app starting!&quot;);<br>    App::new().run();<br>    println!(&quot;Bevy app complete!&quot;);<br>}</pre><p>When you execute cargo run You should see both println! lines in the console, but a bevy window does not yet show up to display anything. Let&#39;s correct¬†that!</p><p>To show a window, we will need to use a Bevy Plugin,‚Ää‚Äî‚ÄäBevy splits separate parts of the app into plugins. To make a window display, we can get off the ground by adding a set of plugins as a group‚Ää‚Äî‚Ääone called DefaultPlugins</p><pre>//main.rs<br>#![warn(clippy::pedantic)]<br>use bevy::prelude::*;<br><br>fn main() {<br>    println!(&quot;Bevy app starting!&quot;);<br>    App::new()<br>        .add_plugins(DefaultPlugins)<br>        .run();<br>}</pre><p>Now, when we execute cargo run we will see a blank¬†window.</p><p>Let‚Äôs add a title to the window‚Ää‚Äî‚Ääinstead of using only the default plugins with their default settings, we want to modify the WindowPlugin to have a title and specific resolution displayed.</p><pre>//main.rs<br>#![warn(clippy::pedantic)]<br><br>use bevy::prelude::*;<br><br>// Window starting dimensions<br>const WINDOW_START_HEIGHT: f32 = 800.0;<br>const WINDOW_START_WIDTH: f32 = 700.0;<br>fn main() {<br>    println!(&quot;Game of life app starting!&quot;);<br>    App::new()<br>        .add_plugins(<br>            DefaultPlugins.set(WindowPlugin {<br>                primary_window: Some(Window {<br>                    title: &quot;Conway&#39;s Game of Life&quot;.into(),<br>                    resolution: (WINDOW_START_WIDTH, WINDOW_START_HEIGHT).into(),<br>                    ..default()<br>                }),<br>                ..default()<br>            })<br>        )<br>        .run();<br>}</pre><p>For this we still use the majority of the DefaultPlugins, but we override the WindowPlugin with our custom settings &amp; leave all others default. Note: The¬†..default() is the part that fills in the remaining elements of the struct for us with the defaults, which for Bevy are quite¬†sane.</p><p>Execute: cargo¬†run</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/700/1*aOaXgG7NtgGXfAss9ny34A.png" /></figure><p>NICE, we have something displayed &amp; our window is titled‚Ää‚Äî‚Äälet‚Äôs commit for good¬†measure!</p><pre>git commit -a -m &quot;Window title and display functionality.&quot;</pre><h3>Adding the game¬†board</h3><p>Now that we have something displayed, let‚Äôs get a game board¬†going.</p><pre>//main.rs<br>#![warn(clippy::pedantic)]<br><br>use bevy::prelude::*;<br><br>//Default for the tile sizes.<br>const TILE_SIZE: u16 = 40;<br><br>struct Board {<br>    squares_wide: u16,<br>    squares_high: u16,<br>}<br><br>fn main() {<br>    println!(&quot;Bevy app starting!&quot;);<br>    let cols = 20;<br>    let rows = 20;<br>    let board = Board {squares_wide: cols, squares_high: rows};<br>    let window_width = TILE_SIZE * board.squares_wide;<br>    let window_height =  TILE_SIZE * board.squares_high;<br>    App::new()<br>        .add_plugins(<br>            DefaultPlugins.set(WindowPlugin {<br>                primary_window: Some(Window {<br>                    title: &quot;Conway&#39;s Game of Life&quot;.into(),<br>                    resolution: (f32::from(window_width), f32::from(window_height)).into(),<br>                    ..default()<br>                }),<br>                ..default()<br>            })<br>        )<br>        .run();<br>}</pre><p>The window displays similar to before, but the implementation is a bit more flexible with a custom board size, so we can change it easily in the future if we want a tiny or massive board (though we‚Äôll likely want to decouple from a fixed pixel count per square if we get too¬†large).</p><p>To actually display something inside the window we need what Bevy calls a camera. In this case for our Game Of Life, we will be using a 2d camera. Bevy is an Entity Container System style engine, and for adding the camera we‚Äôll add it as a system. See <a href="https://bevyengine.org/learn/book/getting-started/ecs/">here</a> for more background and details on the benefits of ECS. The major thing it brings is the ability to separate out the data representations we need for our game from the functions (systems) that use¬†them.</p><p>To add the camera, we will need to create an initialization function that adds the one-time elements to our app, which will be the 2d camera and a background‚Ää‚Äî‚ÄäWe do this by calling¬†.add_systems(Startup, initial_setup) during our app¬†build.</p><pre>//main.rs<br>#![warn(clippy::pedantic)]<br><br>use bevy::prelude::*;<br><br>//Default for the tile sizes.<br>const TILE_SIZE: u16 = 40;<br><br>struct Board {<br>    squares_wide: u16,<br>    squares_high: u16,<br>}<br><br>fn main() {<br>    println!(&quot;Bevy app starting!&quot;);<br>    let cols = 20;<br>    let rows = 20;<br>    let board = Board {squares_wide: cols, squares_high: rows};<br>    let window_width = TILE_SIZE * board.squares_wide;<br>    let window_height =  TILE_SIZE * board.squares_high;<br>    App::new()<br>        .add_plugins(<br>            DefaultPlugins.set(WindowPlugin {<br>                primary_window: Some(Window {<br>                    title: &quot;Conway&#39;s Game of Life&quot;.into(),<br>                    resolution: (f32::from(window_width), f32::from(window_height)).into(),<br>                    ..default()<br>                }),<br>                ..default()<br>            })<br>        )<br>        .add_systems(Startup, initial_setup)<br>        .run();<br>}<br><br>fn initial_setup(mut commands: Commands) {<br>    commands.spawn(Camera2dBundle::default());<br>}</pre><p>The spawn to the command will enqueue a Camera2dBundle to be added to the¬†scene.</p><p>We also need something for the camera to display, so let‚Äôs start with something simple‚Ää‚Äî‚ÄäA beautiful blue background.</p><pre>//main.rs intialize_setup function    <br>//Add after the 2d Camera Spawn.<br>    //Draw the background!<br>    commands.spawn(NodeBundle {<br>        style: Style {<br>            width: Val::Percent(100.0),<br>            height: Val::Percent(100.0),<br>            position_type: PositionType::Absolute,<br>            justify_content: JustifyContent::SpaceAround,<br>            align_items: AlignItems::Center,<br>            ..default()<br>        },<br>        background_color: Color::BLUE.into(),<br>        ..default()<br>    });</pre><p>For this we‚Äôre enqueuing a spawn of a <a href="https://docs.rs/bevy/latest/bevy/prelude/struct.NodeBundle.html">NodeBundle</a> to also be added to the scene. We tell it where to place the element as well as how large it should be in relation to the parent element. If we were to change the Val::Percent to other values, we will see the BG area¬†shrink.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*kWdCIYfDZ2W_abcRZPSEvQ.png" /></figure><p>Execute: cargo¬†run</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*92p57fy-hs96-nHTcSvKUg.png" /></figure><p>That‚Äôs‚Ä¶ a lot of¬†blue.</p><pre>git commit -a -m &quot;Add camera and background on startup.&quot;</pre><p>Okay, great, we now have a background! Let‚Äôs actually draw some board elements.</p><p>For this, we will use bevy‚Äôs built in grid system‚Ä¶ to know how many rows and columns we‚Äôll need to add access to the board struct. Let‚Äôs add it to the method signature of initial_setup¬†.</p><pre>fn initial_setup(mut commands: Commands, board: Res&lt;Board&gt;) {</pre><p>however‚Ä¶ due to Bevy trait constraints this won‚Äôt compile as Board needs the Resource trait, so we will add a derive Resource trait to the¬†Board.</p><pre>#[derive(Resource)]<br>struct Board {<br>    squares_wide: u16,<br>    squares_high: u16,<br>}</pre><p><em>Side note: </em>A resource in Bevy isn‚Äôt one of the letters in ECS, but is instead something that‚Äôs ‚Äúglobally unique‚Äù for the game and can be pulled into any system we need to read or modify the state in. We‚Äôll later add a few more resources and elements to the Board which will be useful in many different systems.</p><p>In addition to changing the method signature and traits of the board, we need to add the board resource to be available for Bevy to pull in. For that we need to add the Board resource to our app in the main function. Only one resource of each type can be added to the app/world at a time, so if we constructed a second board and inserted it, bevy would¬†panic.</p><pre>//main.rs main function<br>//Add this line before the add_systems(Startup, initial_setup) call.<br>    .insert_resource(board)</pre><p>Okay, now we move on to changing our background NodeBundle to be a grid layout. Replace our BEAUTIFUL blue background spawn with one that‚Äôs a grid type. Then after the grid is spawned, we will add some child nodes to¬†it.</p><p>For this we iterate over the columns and and rows to add each of the squares, alternating the color of the grid node between red and¬†black.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*7wTfDXACKDmEemszcpMpSQ.png" /></figure><pre>//main.rs intialize_setup function<br>//Replace the spawn NodeBundle block<br>    commands<br>        .spawn(NodeBundle {<br>            style: Style {<br>                // Create a grid layout, at 100% of the parent element<br>                // Height and width.<br>                display: Display::Grid,<br>                width: Val::Percent(100.0),<br>                height: Val::Percent(100.0),<br>                grid_template_columns: vec![<br>                    GridTrack::auto(); usize::from(board.squares_wide)<br>                ],<br>                grid_template_rows: vec![<br>                    GridTrack::auto(); usize::from(board.squares_high)<br>                ],<br>                ..default()<br>            },<br>            background_color: BackgroundColor(Color::WHITE),<br>            ..default()<br>        })<br>        .with_children(|builder| {<br>            //Every other will be black or red!<br>            for c in 0..board.squares_wide {<br>                for r in 0..board.squares_high {<br>                    let color = if (r + c) % 2 == 0 {<br>                        Color::RED<br>                    } else {<br>                        Color::BLACK<br>                    };<br>                    builder.spawn(NodeBundle {<br>                        style: Style {<br>                            display: Display::Grid,<br>                            ..default()<br>                        },<br>                        background_color: BackgroundColor(color),<br>                        ..default()<br>                    });<br>                }<br>            }<br>        });</pre><p>Okay, in case anything was lost, here‚Äôs a full¬†main.rs</p><pre>//main.rs<br>#![warn(clippy::pedantic)]<br><br>use bevy::prelude::*;<br><br>//Default for the tile sizes.<br>const TILE_SIZE: u16 = 40;<br><br>#[derive(Resource)]<br>struct Board {<br>    squares_wide: u16,<br>    squares_high: u16,<br>}<br><br>fn main() {<br>    println!(&quot;Bevy app starting!&quot;);<br>    let cols = 20;<br>    let rows = 20;<br>    let board = Board {squares_wide: cols, squares_high: rows};<br>    let window_width = TILE_SIZE * board.squares_wide;<br>    let window_height =  TILE_SIZE * board.squares_high;<br>    App::new()<br>        .add_plugins(<br>            DefaultPlugins.set(WindowPlugin {<br>                primary_window: Some(Window {<br>                    title: &quot;Conway&#39;s Game of Life&quot;.into(),<br>                    resolution: (f32::from(window_width), f32::from(window_height)).into(),<br>                    ..default()<br>                }),<br>                ..default()<br>            })<br>        )<br>        .insert_resource(board)<br>        .add_systems(Startup, initial_setup)<br>        .run();<br>}<br><br>fn initial_setup(mut commands: Commands, board: Res&lt;Board&gt;) {<br>    commands.spawn(Camera2dBundle::default());<br>    //Draw the grid layout!<br>    commands<br>        .spawn(NodeBundle {<br>            style: Style {<br>                // Create a grid layout, at 100% of the parent element<br>                // Height and width.<br>                display: Display::Grid,<br>                width: Val::Percent(100.0),<br>                height: Val::Percent(100.0),<br>                grid_template_columns: vec![<br>                    GridTrack::auto(); usize::from(board.squares_wide)<br>                ],<br>                grid_template_rows: vec![<br>                    GridTrack::auto(); usize::from(board.squares_high)<br>                ],<br>                ..default()<br>            },<br>            background_color: BackgroundColor(Color::WHITE),<br>            ..default()<br>        })<br>        .with_children(|builder| {<br>            //Every other will be black or red!<br>            for c in 0..board.squares_wide {<br>                for r in 0..board.squares_high {<br>                    let color = if (r + c) % 2 == 0 {<br>                        Color::RED<br>                    } else {<br>                        Color::BLACK<br>                    };<br>                    builder.spawn(NodeBundle {<br>                        style: Style {<br>                            display: Display::Grid,<br>                            ..default()<br>                        },<br>                        background_color: BackgroundColor(color),<br>                        ..default()<br>                    });<br>                }<br>            }<br>        });<br>}</pre><p>Now let‚Äôs see what we have by executing: cargo¬†run</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*45yvqLScPUOVA1YXz6KAmA.png" /></figure><p>Sweet! Looks like we can play a huge game of checkers on that¬†board!</p><p>Let‚Äôs commit it to be able to return here as we‚Äôre about to change a good amount of stuff! git commit -a -m &quot;Checker board¬†view.&quot;</p><h3>Consistent Game¬†State</h3><p>The every other red + black was nice to demonstrate how to draw, but eventually we‚Äôll need to change the colors of the squares based on their alive/dead status, so let‚Äôs store the board state in our Board Struct. For this we‚Äôll add a 2d vector to the Board¬†object:</p><pre>//main.rs<br>#[derive(Resource)]<br>struct Board {<br>    squares_wide: u16,<br>    squares_high: u16,<br>    squares: Vec&lt;Vec&lt;bool&gt;&gt;,<br>}</pre><p>And we‚Äôll initialize it and pass it into the board constructor.</p><pre>//main.rs main function<br>// After the first println!<br>    let cols = 20;<br>    let rows = 20;<br>    // Create a 2d vector where every other square is on or off.<br>    // This is equivalent to a nested for loop over cols then row elements.<br>    let board_state = (0..cols).map(|col| <br>            (0..rows).map(|row| <br>                (col + row) % 2 == 0)<br>                .collect())<br>        .collect();<br><br>    let board = Board {squares_wide: cols, squares_high: rows, squares: board_state};<br>    let window_width = TILE_SIZE * board.squares_wide;<br>    let window_height =  TILE_SIZE * board.squares_high;<br><br>//main.rs intialize_setup function<br>// within the with_children block, make it use the squares boolean.<br>            for c in 0..board.squares_wide {<br>                for r in 0..board.squares_high {<br>                    let color = if board.squares[usize::from(c)][usize::from(r)] {<br>                        Color::RED<br>                    } else {<br>                        Color::BLACK<br>                    };</pre><p>Ok, so we added a two dimensional array (vector of vectors) that contain a boolean of the state of the square of alive or dead‚Ää‚Äî‚ÄäWe then use that state for knowing what color of square we should¬†spawn.</p><p>This allows us to know what state each square is in without needing some deep knowledge of how the colors are rendered.</p><p>Let‚Äôs commit!</p><p>git commit -a -m &quot;Board now controls alive/dead color.&quot;</p><h3>User Mouse¬†Input</h3><p>Many game engines have complex click handling logic, but fortunately Bevy solves most of this for us‚Ää‚Äî‚ÄäInstead of using a NodeBundle for each RED/BLACK square, we can use a ButtonBundle instead. The way we interact with it is very similar to NodeBundle, but it also has built in support for button presses and mouse hovers. First we‚Äôll migrate to ButtonBundles. We‚Äôre also going to use a White/Black color scheme to be more traditional w/ the Game of Life. Feel free to use whatever color scheme you‚Äôd like. Black will represent an alive square, and white will represent a dead¬†one.</p><pre>//main.rs<br>//In initial_setup - Replace the child NodeBundle with one for a ButtonBundle.<br>#[allow(clippy::needless_pass_by_value)]<br>fn initial_setup(mut commands: Commands, board: Res&lt;Board&gt;) {<br>    commands.spawn(Camera2dBundle::default());<br>    //Button style<br>    let button_style = Style {<br>        display: Display::Grid,<br>        justify_content: JustifyContent::Center,<br>        align_items: AlignItems::Center,<br>        ..default()<br>    };<br>    //Draw the grid layout!<br>    commands<br>        .spawn(NodeBundle {<br>            style: Style {<br>                // Create a grid layout, at 100% of the parent element<br>                // Height and width.<br>                display: Display::Grid,<br>                width: Val::Percent(100.0),<br>                height: Val::Percent(100.0),<br>                grid_template_columns: vec![<br>                    GridTrack::auto(); usize::from(board.squares_wide)<br>                ],<br>                grid_template_rows: vec![<br>                    GridTrack::auto(); usize::from(board.squares_high)<br>                ],<br>                ..default()<br>            },<br>            background_color: BackgroundColor(Color::WHITE),<br>            ..default()<br>        })<br>        .with_children(|builder| {<br>            //Every other will be black or white!<br>            for c in 0..board.squares_wide {<br>                for r in 0..board.squares_high {<br>                    let color = if board.squares[usize::from(c)][usize::from(r)] {<br>                        Color::BLACK<br>                    } else {<br>                        Color::WHITE<br>                    };<br>                    builder.spawn(ButtonBundle {<br>                        style: button_style.clone(),<br>                        background_color: BackgroundColor(color),<br>                        ..default()<br>                    });<br>                }<br>            }<br>        });<br>}</pre><p>And to handle the mouse clicks (button presses), we‚Äôll need a new system. This system will be executed on each Update event. The update schedule is different from what we‚Äôll use later for game movement, but it‚Äôs the best for showing rapid updates for our game-users.</p><pre>//main.rs main - Add another system to the app after the initial_setup addition.<br>        .add_systems(Update, button_system)<br>//Add to the bottom of the file.<br>#[allow(clippy::type_complexity)]<br>fn button_system(mut interaction_query: Query&lt;<br>    (<br>        &amp;Interaction,<br>        &amp;mut BackgroundColor,<br>    ),<br>    (Changed&lt;Interaction&gt;, With&lt;Button&gt;),<br>&gt;) {<br>    for (interaction, mut color) in &amp;mut interaction_query {<br>        match *interaction {<br>            Interaction::Pressed =&gt; {<br>                println!(&quot;Button pressed!&quot;);<br>                *color = if color.0.eq(&amp;Color::BLACK) {<br>                    Color::WHITE<br>                }<br>                else {<br>                    Color::BLACK<br>                }.into();<br>            },<br>            Interaction::Hovered | Interaction::None =&gt; {},<br>        }<br>    }<br>}</pre><p>Now, run the app‚Ää‚Äî‚Ääyou can now toggle different squares on and off! Make your own pattern for¬†fun.</p><p>Congratulations, we just made an incredibly boring version of MSPaint!¬†ü•≥üéâüéâü•≥</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*kKltZfCk__NvDAPZ1yy67Q.png" /></figure><p>git commit -a -m &quot;Minimal working square toggle with the¬†mouse.&quot;</p><p>Keen observers will start to notice a bit of code smell rising up‚Ää‚Äî‚ÄäWe have the Board struct that is supposed to contain the state of the squares, but those true/false combinations no longer match our world when a button is toggled. To do this, we‚Äôll need to change our trusty 2d vector values as well. The reason for the separate game-state array (from the UX elements) might be unclear now, but we‚Äôll round that out in due time. We should strive for one Source of Truth‚Ñ¢Ô∏è for our states, and here we have strayed from that. Let‚Äôs correct¬†it!</p><p>At first glance it seems the best place to add it is in that button handler‚Ää‚Äî‚ÄäWhile that is true, we will need some additional information for that, as when the button is clicked it doesn‚Äôt actually ‚Äúknow‚Äù where it is in the grid to then map it to the 2d vector coordinates. The good news is we can add the coords to the bundles when we spawn them so when it is clicked we have that information.</p><p>Let‚Äôs create a new GridLocation Component struct.</p><pre>//main.rs<br>//below the board struct.<br>#[derive(Component, Debug)]<br>struct GridLocation {<br>    row: u16,<br>    column: u16<br>}</pre><p>And in initial_setupafter our color setting we spawn the ButtonBundle and the GridLocation in a¬†tuple.</p><pre>//main.rs initial_setup<br>//Instead of using the builder to spawn a ButtonBundle, we do it as a tuple with a GridLocation.<br>//After the color determination, replace the existing spawn.<br>                    let grid_loc = GridLocation {column: c, row: r};<br>                    builder.spawn(<br>                        (ButtonBundle {<br>                            style: button_style.clone(),<br>                            background_color: BackgroundColor(color),<br>                            ..default()<br>                        }, grid_loc)<br>                    );</pre><p>This lets us change our button system query to include the grid location. We also need to add a mutable reference to the board as we‚Äôre planning to modify the board on a button¬†click.</p><pre>//main.rs<br>#[allow(clippy::type_complexity)]<br>fn button_system(mut interaction_query: Query&lt;<br>        (<br>            &amp;Interaction,<br>            &amp;mut BackgroundColor,<br>            &amp;GridLocation<br>        ),<br>        (Changed&lt;Interaction&gt;, With&lt;Button&gt;),<br>    &gt;, mut board: ResMut&lt;Board&gt;) {<br>    for (interaction, mut color, grid_loc) in &amp;mut interaction_query {<br>        match *interaction {<br>            Interaction::Pressed =&gt; {<br>                let r = usize::from(grid_loc.row);<br>                let c = usize::from(grid_loc.column);<br>                //Get the game state.<br>                let cur = board.squares[c][r];<br>                println!(&quot;Button pressed at ({c},{r}) -- Currently:{cur}&quot;);<br><br>                if cur { //Alive to dead<br>                    *color = Color::WHITE.into();<br>                }<br>                else {<br>                    *color = Color::BLACK.into();<br>                }<br>                board.squares[c][r] = !cur;<br>            },<br>            Interaction::Hovered | Interaction::None =&gt; {},<br>        }<br>    }<br>}</pre><p>And with that‚Ä¶ it looks like we have the same functionality!!! Wait‚Ä¶ what?? Why did we do it then? The reason is to have one Source of Truth‚Ñ¢Ô∏è for our game state‚Ää‚Äî‚Ääthe UX elements could be a place to store this single source, but that mixes the the Game of Life rules with the UX methods we use to display things, which isn‚Äôt¬†ideal.</p><p>For review, the full¬†main.rs</p><pre>//main.rs<br>#![warn(clippy::pedantic)]<br><br>use bevy::prelude::*;<br><br>//Default for the tile sizes.<br>const TILE_SIZE: u16 = 40;<br><br>#[derive(Resource)]<br>struct Board {<br>    squares_wide: u16,<br>    squares_high: u16,<br>    squares: Vec&lt;Vec&lt;bool&gt;&gt;,<br>}<br><br>#[derive(Component, Debug)]<br>struct GridLocation {<br>    row: u16,<br>    column: u16<br>}<br><br>fn main() {<br>    println!(&quot;Bevy app starting!&quot;);<br>    let cols = 20;<br>    let rows = 20;<br>    // Create a 2d vector where every other square is on or off.<br>    // This is equivalent to a nested for loop over cols then row elements.<br>    let board_state = (0..cols).map(|col| <br>        (0..rows).map(|row| <br>            (col + row) % 2 == 0)<br>            .collect())<br>    .collect();<br>    let board = Board {squares_wide: cols, squares_high: rows, squares: board_state};<br>    let window_width = TILE_SIZE * board.squares_wide;<br>    let window_height =  TILE_SIZE * board.squares_high;<br>    App::new()<br>        .add_plugins(<br>            DefaultPlugins.set(WindowPlugin {<br>                primary_window: Some(Window {<br>                    title: &quot;Conway&#39;s Game of Life&quot;.into(),<br>                    resolution: (f32::from(window_width), f32::from(window_height)).into(),<br>                    ..default()<br>                }),<br>                ..default()<br>            })<br>        )<br>        .insert_resource(board)<br>        .add_systems(Startup, initial_setup)<br>        .add_systems(Update, button_system)<br>        .run();<br>}<br><br>fn initial_setup(mut commands: Commands, board: Res&lt;Board&gt;) {<br>    commands.spawn(Camera2dBundle::default());<br>    //Button style<br>    let button_style = Style {<br>        display: Display::Grid,<br>        justify_content: JustifyContent::Center,<br>        align_items: AlignItems::Center,<br>        ..default()<br>    };<br>    //Draw the grid layout!<br>    commands<br>        .spawn(NodeBundle {<br>            style: Style {<br>                // Create a grid layout, at 100% of the parent element<br>                // Height and width.<br>                display: Display::Grid,<br>                width: Val::Percent(100.0),<br>                height: Val::Percent(100.0),<br>                grid_template_columns: vec![<br>                    GridTrack::auto(); usize::from(board.squares_wide)<br>                ],<br>                grid_template_rows: vec![<br>                    GridTrack::auto(); usize::from(board.squares_high)<br>                ],<br>                ..default()<br>            },<br>            background_color: BackgroundColor(Color::WHITE),<br>            ..default()<br>        })<br>        .with_children(|builder| {<br>            //Every other will be black or white!<br>            for c in 0..board.squares_wide {<br>                for r in 0..board.squares_high {<br>                    let color = if board.squares[usize::from(c)][usize::from(r)] {<br>                        Color::BLACK<br>                    } else {<br>                        Color::WHITE<br>                    };<br>                    let grid_loc = GridLocation {column: c, row: r};<br>                    builder.spawn(<br>                        (ButtonBundle {<br>                            style: button_style.clone(),<br>                            background_color: BackgroundColor(color),<br>                            ..default()<br>                        }, grid_loc)<br>                    );<br>                }<br>            }<br>        });<br>}<br><br>#[allow(clippy::type_complexity)]<br>fn button_system(mut interaction_query: Query&lt;<br>    (<br>        &amp;Interaction,<br>        &amp;mut BackgroundColor,<br>        &amp;GridLocation<br>    ),<br>    (Changed&lt;Interaction&gt;, With&lt;Button&gt;),<br>&gt;, mut board: ResMut&lt;Board&gt;) {<br>    for (interaction, mut color, grid_loc) in &amp;mut interaction_query {<br>        match *interaction {<br>            Interaction::Pressed =&gt; {<br>                let r = usize::from(grid_loc.row);<br>                let c = usize::from(grid_loc.column);<br>                //Get the game state.<br>                let cur = board.squares[c][r];<br>                println!(&quot;Button pressed at ({c},{r}) -- Currently:{cur}&quot;);<br><br>                if cur { //Alive to dead<br>                    *color = Color::WHITE.into();<br>                }<br>                else {<br>                    *color = Color::BLACK.into();<br>                }<br>                board.squares[c][r] = !cur;<br>            },<br>            Interaction::Hovered | Interaction::None =&gt; {},<br>        }<br>    }<br>}</pre><p>git commit -a -m &quot;Use the game board array as the source of a square‚Äôs¬†state.&quot;</p><h3>Add Game¬†Movement</h3><p>Toggling buttons back and forth doesn‚Äôt exactly constitute a game, so let‚Äôs start adding some life to the board‚Ää‚Äî‚ÄäFirst step on the journey is to toggle the square colors back and¬†forth.</p><p>For that, we‚Äôll add a new system which will be executed on a FixedUpdate (time) schedule, not on every Update event. If we were on each Update it would progress <em>far </em>too fast to keep track¬†of.</p><pre>//main.rs<br><br>//below TILE_SIZE<br>const UPDATE_RATE_SEC: f64 = 0.5;<br>//main.rs in the main function<br>// To the app initialization<br>        .insert_resource(Time::&lt;Fixed&gt;::from_seconds(UPDATE_RATE_SEC))<br>        .add_systems(FixedUpdate, update_board)<br>        <br><br>//main.rs below button_system<br>//Update the board for every entity with both a backgroundcolor and a gridlocation.<br>fn update_board(mut query: Query&lt;(&amp;mut BackgroundColor, &amp;GridLocation)&gt;, mut board: ResMut&lt;Board&gt;) {<br>    for (mut color, grid_loc) in &amp;mut query {<br>        let c = usize::from(grid_loc.column);<br>        let r = usize::from(grid_loc.row);<br>        let cur = board.squares[c][r];<br>        // for now, toggle back and forth.<br>        if cur {<br>            *color = Color::WHITE.into();<br>        } else {<br>            *color = Color::BLACK.into();<br>        }<br>        board.squares[c][r] = !cur;<br>    }<br>}</pre><p>execute it with cargo run You should see the tile colors oscillate every half second -- Houston, we have¬†‚Ä¶ movement!</p><p>While we can still click to toggle things‚Ä¶ it‚Äôs not exactly a game... but let‚Äôs commit¬†anyways.</p><p>git commit -a -m &quot;Time based toggle of the squares back and¬†forth.&quot;</p><p>For fun you can change the FixedUpdate to Update to see the crazy chaos that comes with updating WAY too¬†fast!</p><h3>The Game of Life and¬†Death</h3><p>Let‚Äôs add in the game of life¬†rules.</p><p>For some background, Conway‚Äôs rules¬†are:</p><pre>Any live cell with fewer than two live neighbours dies, as if by underpopulation.<br>Any live cell with two or three live neighbours lives on to the next generation.<br>Any live cell with more than three live neighbours dies, as if by overpopulation.<br>Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.</pre><p>To support easier evaluation, let‚Äôs create a function to calculate the number of neighbors.</p><p>This function checks our 8 (in bounds) neighbors to get an alive neighbor count. We calculate <em>all </em>neighbors <em>before </em>modifying the board object as if we do the check &amp; set while iterating through, we will inappropriately change the outcome of the yet to be evaluated cells.</p><pre>//main.rs below update_board<br>fn get_alive_neighbor_counts(board: &amp;Board) -&gt; Vec&lt;Vec&lt;usize&gt;&gt; {<br>    let height = usize::from(board.squares_high);<br>    let width = usize::from(board.squares_wide);<br>    let mut neighbor_counts = vec![vec![0; height]; width];<br>    for (c, row) in neighbor_counts.iter_mut().enumerate() {<br>        for (r, item) in  row.iter_mut().enumerate() {<br>            let mut neighbors = 0;<br>            //Top<br>            if r &gt; 0 {<br>                //T/L<br>                if c &gt; 0 &amp;&amp; board.squares[c-1][r-1] {<br>                    neighbors += 1;<br>                }<br>                //T/C<br>                if board.squares[c][r-1] {<br>                    neighbors += 1;<br>                }<br>                //T/R<br>                if c+1 &lt; width &amp;&amp; board.squares[c+1][r-1] {<br>                    neighbors += 1;<br>                }<br>            }<br>            //Left<br>            if c &gt; 0 &amp;&amp; board.squares[c-1][r] {<br>                neighbors += 1;<br>            }<br>            //Right<br>            if c+1 &lt; width &amp;&amp; board.squares[c+1][r] {<br>                neighbors += 1;<br>            }<br>            //Bottom<br>            if r+1 &lt; height {<br>                //B/L<br>                if c &gt; 0 &amp;&amp; board.squares[c-1][r+1] {<br>                    neighbors += 1;<br>                }<br>                //B/C<br>                if board.squares[c][r+1] {<br>                    neighbors += 1;<br>                }<br>                //B/R<br>                if c+1 &lt; width &amp;&amp; board.squares[c+1][r+1] {<br>                    neighbors += 1;<br>                }<br>            }<br>            *item = neighbors;<br>        }<br>    }<br>    neighbor_counts<br>}</pre><p>Now instead of our boring back and forth we can update the board using these¬†rules!</p><pre>//main.rs<br>//Update the board for every entity with both a backgroundcolor and a gridlocation..=<br>fn update_board(mut query: Query&lt;(&amp;mut BackgroundColor, &amp;GridLocation)&gt;, mut board: ResMut&lt;Board&gt;) {<br>    //Fetch the neighbor counts.<br>    let neighbor_counts = get_alive_neighbor_counts(board.as_ref());<br>    for (mut color, grid_loc) in &amp;mut query {<br>        let c = usize::from(grid_loc.column);<br>        let r = usize::from(grid_loc.row);<br>        let cur = board.squares[c][r];<br>        let n = neighbor_counts[c][r];<br>        let mut new_state = cur;<br>        if cur {<br>            // Live cell<br>            //fewer than two live neighbours dies, as if by underpopulation.<br>            if n &lt; 2 {<br>                //Underpop<br>                new_state = false;<br>            }<br>            //two or three live neighbours lives on to the next generation.<br>            if n == 2 || n == 3 {<br>                //We live!<br>                new_state = true;<br>            }<br>            //more than three live neighbours dies, as if by overpopulation.<br>            if n &gt; 3 {<br>                //Overpop<br>                new_state = false;<br>            }<br>        } else {<br>            // Dead Cell<br>            //exactly three live neighbours becomes a live cell, as if by reproduction.<br>            if n == 3 {<br>                //breeeed<br>                new_state = true;<br>            }<br>        }<br>        //Update the data<br>        board.squares[c][r] = new_state;<br>        if new_state {<br>            *color = Color::BLACK.into();<br>        } else {<br>            *color = Color::WHITE.into();<br>        }<br>    }<br>}</pre><p>Alright‚Ää‚Äî‚ÄäExecute things with cargo¬†run</p><p>NICE! Looks like we&#39;re movin‚Äô! After a while you‚Äôll start to see the checkerboard pattern disappear &amp; likely some patterns begin to stabilize. We can then change it up a bit with the¬†mouse!</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/796/1*BPE2dpC4lMlkUsmUzg9WEg.gif" /></figure><p>Here‚Äôs the full¬†main.rs</p><pre>//main.rs<br>#![warn(clippy::pedantic)]<br><br>use bevy::prelude::*;<br><br>//Default for the tile sizes.<br>const TILE_SIZE: u16 = 40;<br>const UPDATE_RATE_SEC: f64 = 0.5;<br><br>#[derive(Resource)]<br>struct Board {<br>    squares_wide: u16,<br>    squares_high: u16,<br>    squares: Vec&lt;Vec&lt;bool&gt;&gt;,<br>}<br><br>#[derive(Component, Debug)]<br>struct GridLocation {<br>    row: u16,<br>    column: u16<br>}<br><br>fn main() {<br>    println!(&quot;Bevy app starting!&quot;);<br>    let cols = 20;<br>    let rows = 20;<br>    // Create a 2d vector where every other square is on or off.<br>    // This is equivalent to a nested for loop over cols then row elements.<br>    let board_state = (0..cols).map(|col| <br>        (0..rows).map(|row| <br>            (col + row) % 2 == 0)<br>            .collect())<br>    .collect();<br>    let board = Board {squares_wide: cols, squares_high: rows, squares: board_state};<br>    let window_width = TILE_SIZE * board.squares_wide;<br>    let window_height =  TILE_SIZE * board.squares_high;<br>    App::new()<br>        .add_plugins(<br>            DefaultPlugins.set(WindowPlugin {<br>                primary_window: Some(Window {<br>                    title: &quot;Conway&#39;s Game of Life&quot;.into(),<br>                    resolution: (f32::from(window_width), f32::from(window_height)).into(),<br>                    ..default()<br>                }),<br>                ..default()<br>            })<br>        )<br>        .insert_resource(board)<br>        .insert_resource(Time::&lt;Fixed&gt;::from_seconds(UPDATE_RATE_SEC))<br>        .add_systems(FixedUpdate, update_board)<br>        .add_systems(Startup, initial_setup)<br>        .add_systems(Update, button_system)<br>        .run();<br>}<br><br>fn initial_setup(mut commands: Commands, board: Res&lt;Board&gt;) {<br>    commands.spawn(Camera2dBundle::default());<br>    //Button style<br>    let button_style = Style {<br>        display: Display::Grid,<br>        justify_content: JustifyContent::Center,<br>        align_items: AlignItems::Center,<br>        ..default()<br>    };<br>    //Draw the grid layout!<br>    commands<br>        .spawn(NodeBundle {<br>            style: Style {<br>                // Create a grid layout, at 100% of the parent element<br>                // Height and width.<br>                display: Display::Grid,<br>                width: Val::Percent(100.0),<br>                height: Val::Percent(100.0),<br>                grid_template_columns: vec![<br>                    GridTrack::auto(); usize::from(board.squares_wide)<br>                ],<br>                grid_template_rows: vec![<br>                    GridTrack::auto(); usize::from(board.squares_high)<br>                ],<br>                ..default()<br>            },<br>            background_color: BackgroundColor(Color::WHITE),<br>            ..default()<br>        })<br>        .with_children(|builder| {<br>            //Every other will be black or white!<br>            for c in 0..board.squares_wide {<br>                for r in 0..board.squares_high {<br>                    let color = if board.squares[usize::from(c)][usize::from(r)] {<br>                        Color::BLACK<br>                    } else {<br>                        Color::WHITE<br>                    };<br>                    let grid_loc = GridLocation {column: c, row: r};<br>                    builder.spawn(<br>                        (ButtonBundle {<br>                            style: button_style.clone(),<br>                            background_color: BackgroundColor(color),<br>                            ..default()<br>                        }, grid_loc)<br>                    );<br>                }<br>            }<br>        });<br>}<br><br>#[allow(clippy::type_complexity)]<br>fn button_system(mut interaction_query: Query&lt;<br>    (<br>        &amp;Interaction,<br>        &amp;mut BackgroundColor,<br>        &amp;GridLocation<br>    ),<br>    (Changed&lt;Interaction&gt;, With&lt;Button&gt;),<br>&gt;, mut board: ResMut&lt;Board&gt;) {<br>    for (interaction, mut color, grid_loc) in &amp;mut interaction_query {<br>        match *interaction {<br>            Interaction::Pressed =&gt; {<br>                let r = usize::from(grid_loc.row);<br>                let c = usize::from(grid_loc.column);<br>                //Get the game state.<br>                let cur = board.squares[c][r];<br>                println!(&quot;Button pressed at ({c},{r}) -- Currently:{cur}&quot;);<br><br>                if cur { //Alive to dead<br>                    *color = Color::WHITE.into();<br>                }<br>                else {<br>                    *color = Color::BLACK.into();<br>                }<br>                board.squares[c][r] = !cur;<br>            },<br>            Interaction::Hovered | Interaction::None =&gt; {},<br>        }<br>    }<br>}<br><br>fn update_board(mut query: Query&lt;(&amp;mut BackgroundColor, &amp;GridLocation)&gt;, mut board: ResMut&lt;Board&gt;) {<br>    //Fetch the neighbor counts.<br>    let neighbor_counts = get_alive_neighbor_counts(board.as_ref());<br>    for (mut color, grid_loc) in &amp;mut query {<br>        let c = usize::from(grid_loc.column);<br>        let r = usize::from(grid_loc.row);<br>        let cur = board.squares[c][r];<br>        let n = neighbor_counts[c][r];<br>        let mut new_state = cur;<br>        if cur {<br>            // Live cell<br>            //fewer than two live neighbours dies, as if by underpopulation.<br>            if n &lt; 2 {<br>                //Underpop<br>                new_state = false;<br>            }<br>            //two or three live neighbours lives on to the next generation.<br>            if n == 2 || n == 3 {<br>                //We live!<br>                new_state = true;<br>            }<br>            //more than three live neighbours dies, as if by overpopulation.<br>            if n &gt; 3 {<br>                //Overpop<br>                new_state = false;<br>            }<br>        } else {<br>            // Dead Cell<br>            //exactly three live neighbours becomes a live cell, as if by reproduction.<br>            if n == 3 {<br>                //breeeed<br>                new_state = true;<br>            }<br>        }<br>        //Update the data<br>        board.squares[c][r] = new_state;<br>        if new_state {<br>            *color = Color::BLACK.into();<br>        } else {<br>            *color = Color::WHITE.into();<br>        }<br>    }<br>}<br><br>fn get_alive_neighbor_counts(board: &amp;Board) -&gt; Vec&lt;Vec&lt;usize&gt;&gt; {<br>    let height = usize::from(board.squares_high);<br>    let width = usize::from(board.squares_wide);<br>    let mut neighbor_counts = vec![vec![0; height]; width];<br>    for (c, row) in neighbor_counts.iter_mut().enumerate() {<br>        for (r, item) in  row.iter_mut().enumerate() {<br>            let mut neighbors = 0;<br>            //Top<br>            if r &gt; 0 {<br>                //T/L<br>                if c &gt; 0 &amp;&amp; board.squares[c-1][r-1] {<br>                    neighbors += 1;<br>                }<br>                //T/C<br>                if board.squares[c][r-1] {<br>                    neighbors += 1;<br>                }<br>                //T/R<br>                if c+1 &lt; width &amp;&amp; board.squares[c+1][r-1] {<br>                    neighbors += 1;<br>                }<br>            }<br>            //Left<br>            if c &gt; 0 &amp;&amp; board.squares[c-1][r] {<br>                neighbors += 1;<br>            }<br>            //Right<br>            if c+1 &lt; width &amp;&amp; board.squares[c+1][r] {<br>                neighbors += 1;<br>            }<br>            //Bottom<br>            if r+1 &lt; height {<br>                //B/L<br>                if c &gt; 0 &amp;&amp; board.squares[c-1][r+1] {<br>                    neighbors += 1;<br>                }<br>                //B/C<br>                if board.squares[c][r+1] {<br>                    neighbors += 1;<br>                }<br>                //B/R<br>                if c+1 &lt; width &amp;&amp; board.squares[c+1][r+1] {<br>                    neighbors += 1;<br>                }<br>            }<br>            *item = neighbors;<br>        }<br>    }<br>    neighbor_counts<br>}</pre><p>git commit -a -m &quot;Implement the game logic for life and¬†death.&quot;</p><p>Right on, right on, right on! So we‚Äôve implemented the game logic and can toggle squares on and off <em>if </em>we‚Äôre fast enough. However‚Ä¶ that doesn‚Äôt allow for much time‚Ää‚Äî‚ÄäYou can see in the gif my frustration that the deaths happened before I could click fast enough to sustain the population!</p><p>To allow for more thoughtful setting of the board state, let‚Äôs add in the ability to allow the user to pause the game logic so we can take our time creating the patterns.</p><p>This will allow the user to create Game of Life shapes like oscillators and¬†gliders!</p><p>Below the oscillators are the top 4 items, and there‚Äôs a glider below that moves down and to the¬†right.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/796/1*aPQemNdgp4lOT9FF5UJPAw.gif" /></figure><h3>Taking Keyboard Input + updating GameState.</h3><p>Ok, so our next goal will be to allow the users to hit the space-bar and pause the game progress such that they can click and make their own patterns with enough time without the life rules kicking in and killing off some poor square too early. For this, we will use the built-in bevy concept of a State. States are built into many features of the Bevy engine and allow us to run or <em>not </em>run certain systems depending on the current¬†state.</p><p>We‚Äôll create a GameState enum, deriving many traits (including States -Required by bevy). We also need to set the default Enum state the game will initially be in when we add the state to the¬†app.</p><pre>//main.rs<br>//Above the Board struct.<br>#[derive(Debug, Default, Clone, Eq, PartialEq, Hash, States)]<br>enum GameState {<br>    #[default]<br>    Running,<br>    Paused,<br>}</pre><p>Then we add the state to the app and we can convert the update_board function to be contingent on the Running gamestate.</p><pre>//main.rs main function, after the insert_resources statements.<br>    .add_state::&lt;GameState&gt;()<br>//Replace the current single FixedUpdate system<br>    .add_systems(FixedUpdate, update_board.run_if(in_state(GameState::Running)))</pre><p>We then can add a keyboard_system that‚Äôs similar in many ways to the button_system. For state management, we will need to modify what state the game will be in next iteration, not the state we‚Äôre currently in, so we modify the NextState&lt;GameState&gt; we¬†receive.</p><pre>//main.rs<br>// Below the existing button_system<br>#[allow(clippy::needless_pass_by_value)]<br>fn keyboard_system(keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;, game_state: Res&lt;State&lt;GameState&gt;&gt;, mut next_game_state: ResMut&lt;NextState&lt;GameState&gt;&gt;) {<br>    if keyboard_input.just_pressed(KeyCode::Space) {<br>        match game_state.to_owned() {<br>            GameState::Running =&gt; {<br>                println!(&quot;Pausing&quot;);<br>                next_game_state.set(GameState::Paused);<br>            },<br>            GameState::Paused =&gt; {<br>                println!(&quot;Running&quot;);<br>                next_game_state.set(GameState::Running);<br>            },<br>        }<br>    }<br>}</pre><p>Sweet‚Ää‚Äî‚Ääthis keyboard system now will toggle the game between running and paused. The only method currently contingent on <strong>Running</strong> it is the update_board function that runs the game¬†rules.</p><pre>//main.rs<br>// main function, add the keyboard_system on update after button_system<br>.add_systems(Update, keyboard_system)</pre><p>Now, how about we add in the ability to clear the board when the ‚ÄúC‚Äù key is pressed, that way if we want to start fresh, we don‚Äôt have to click off all the black squares. Ok, should be easy enough, we already have the keyboard event handler, however we‚Äôll need access to the game board as¬†well.</p><pre>#[allow(clippy::needless_pass_by_value)]<br>fn keyboard_system(keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;, game_state: Res&lt;State&lt;GameState&gt;&gt;, mut next_game_state: ResMut&lt;NextState&lt;GameState&gt;&gt;, <br>    mut board: ResMut&lt;Board&gt;) {<br>    if keyboard_input.just_pressed(KeyCode::Space) {<br>        match game_state.to_owned() {<br>            GameState::Running =&gt; {<br>                println!(&quot;Pausing&quot;);<br>                next_game_state.set(GameState::Paused);<br>            },<br>            GameState::Paused =&gt; {<br>                println!(&quot;Running&quot;);<br>                next_game_state.set(GameState::Running);<br>            },<br>        }<br>    }<br>    if keyboard_input.just_pressed(KeyCode::C) {<br>        println!(&quot;Clear&quot;);<br>        for c in 0..usize::from(board.squares_wide) {<br>            for r in 0..usize::from(board.squares_high) {<br>                board.squares[c][r] = false;<br>            }<br>        }<br>    }<br>}</pre><p>If you execute cargo run it pauses fine, but there‚Äôs some odd behavior with clear‚Ää‚Äî‚Ääif it‚Äôs paused, we need to resume before the clear¬†happens.</p><p>Our first reflex to fix this might be to add the same queries on color and grid_loc like we have elsewhere into the keyboard system‚Ä¶ but when doing so, we might take a step back and realize we‚Äôre doing this whole ‚Äúupdate the square color‚Äù in an awful lot of places. Let‚Äôs pull out the drawing into it‚Äôs own¬†system.</p><pre>//main.rs<br>// After update_board<br>#[allow(clippy::needless_pass_by_value)]<br>fn draw_board(mut query: Query&lt;(&amp;mut BackgroundColor, &amp;GridLocation)&gt;, board: Res&lt;Board&gt;) {<br>    for (mut color, grid_loc) in &amp;mut query {<br>        let alive = board.squares[grid_loc.column][grid_loc.row];<br>        if alive {<br>            *color = Color::BLACK.into();<br>        } else {<br>            *color = Color::WHITE.into();<br>        }<br>    }<br>}</pre><p>We then should add it in as a system, but we also have two other Update scheduled systems‚Ää‚Äî‚Ääfor this we‚Äôll use a slightly different way to add them in. We‚Äôll use a chained tuple on update as shown¬†here:</p><pre>//main.rs main function:<br>// Remove all add_systems(Update... lines and replace with:<br>.add_systems(Update, (button_system, keyboard_system, draw_board).chain())</pre><p>Now, this will cause a bit of a different behavior in our system‚Ää‚Äî‚ÄäIt will guarantee for the Update scheduled events, that the systems that are in the chained tuple will be executed in the order they are listed, so button, keyboard, then draw. This allows the board to be cleared before the board may be drawn. Out of order in this case isn‚Äôt hugely impactful as we would update on the next Update tick, which is rapid, but there are other things later that will benefit from the user input being before the drawing¬†phase.</p><p>If you run it now you should see the board clear properly, even if¬†paused.</p><p>Before we commit we should also remove the other spots we currently set the UX color (like in update_board). This will also allow us to prune some method parameters.</p><p>Updated update_board</p><pre>fn update_board(mut query: Query&lt;&amp;GridLocation&gt;, mut board: ResMut&lt;Board&gt;) {<br>    //Fetch the neighbor counts.<br>    let neighbor_counts = get_alive_neighbor_counts(board.as_ref());<br>    for grid_loc in &amp;mut query {<br>        let c = usize::from(grid_loc.column);<br>        let r = usize::from(grid_loc.row);<br>        let cur = board.squares[c][r];<br>        let n = neighbor_counts[c][r];<br>        let mut new_state = cur;<br>        if cur {<br>            // Live cell<br>            //fewer than two live neighbours dies, as if by underpopulation.<br>            if n &lt; 2 {<br>                //Underpop<br>                new_state = false;<br>            }<br>            //two or three live neighbours lives on to the next generation.<br>            if n == 2 || n == 3 {<br>                //We live!<br>                new_state = true;<br>            }<br>            //more than three live neighbours dies, as if by overpopulation.<br>            if n &gt; 3 {<br>                //Overpop<br>                new_state = false;<br>            }<br>        } else {<br>            // Dead Cell<br>            //exactly three live neighbours becomes a live cell, as if by reproduction.<br>            if n == 3 {<br>                //breeeed<br>                new_state = true;<br>            }<br>        }<br>        //Update the data<br>        board.squares[c][r] = new_state;<br>    }<br>}</pre><p>updated button_system</p><pre>#[allow(clippy::type_complexity)]<br>fn button_system(mut interaction_query: Query&lt;<br>    (<br>        &amp;Interaction,<br>        &amp;GridLocation,<br>    ),<br>    (Changed&lt;Interaction&gt;, With&lt;Button&gt;),<br>&gt;, mut board: ResMut&lt;Board&gt;) {<br>    for (interaction, grid_loc) in &amp;mut interaction_query {<br>        match *interaction {<br>            Interaction::Pressed =&gt; {<br>                let r = usize::from(grid_loc.row);<br>                let c = usize::from(grid_loc.column);<br>                //Get the game state.<br>                let cur = board.squares[c][r];<br>                println!(&quot;Button pressed at ({c},{r}) -- Currently:{cur}&quot;);<br>                board.squares[c][r] = !cur;<br>            },<br>            Interaction::Hovered | Interaction::None =&gt; {},<br>        }<br>    }<br>}</pre><p>A major strength of ECS is that is allows this type of separation of components from each other. The above is a concrete example where we can prune any care about UX from the keyboard_system, mouse_system, and update_board functions but still maintain the same functionality. This is useful if we wanted to add some feature where perhaps we want to only draw a subset of the screen, or change the UX experience to something like a <a href="https://github.com/ratatui-org/ratatui">ratatui </a>console and the code changes may only be required in the draw_board function.</p><p>Alright‚Ää‚Äî‚Äälots of updates, here‚Äôs the full¬†main.rs</p><pre>//main.rs<br>#![warn(clippy::pedantic)]<br><br>use bevy::prelude::*;<br><br>//Default for the tile sizes.<br>const TILE_SIZE: u16 = 40;<br>const UPDATE_RATE_SEC: f64 = 0.5;<br><br>#[derive(Debug, Default, Clone, Eq, PartialEq, Hash, States)]<br>enum GameState {<br>    #[default]<br>    Running,<br>    Paused,<br>}<br><br>#[derive(Resource)]<br>struct Board {<br>    squares_wide: u16,<br>    squares_high: u16,<br>    squares: Vec&lt;Vec&lt;bool&gt;&gt;,<br>}<br><br>#[derive(Component, Debug)]<br>struct GridLocation {<br>    row: u16,<br>    column: u16<br>}<br><br>fn main() {<br>    println!(&quot;Bevy app starting!&quot;);<br>    let cols = 20;<br>    let rows = 20;<br>    // Create a 2d vector where every other square is on or off.<br>    // This is equivalent to a nested for loop over cols then row elements.<br>    let board_state = (0..cols).map(|col| <br>        (0..rows).map(|row| <br>            (col + row) % 2 == 0)<br>            .collect())<br>    .collect();<br>    let board = Board {squares_wide: cols, squares_high: rows, squares: board_state};<br>    let window_width = TILE_SIZE * board.squares_wide;<br>    let window_height =  TILE_SIZE * board.squares_high;<br>    App::new()<br>        .add_plugins(<br>            DefaultPlugins.set(WindowPlugin {<br>                primary_window: Some(Window {<br>                    title: &quot;Conway&#39;s Game of Life&quot;.into(),<br>                    resolution: (f32::from(window_width), f32::from(window_height)).into(),<br>                    ..default()<br>                }),<br>                ..default()<br>            })<br>        )<br>        .insert_resource(board)<br>        .insert_resource(Time::&lt;Fixed&gt;::from_seconds(UPDATE_RATE_SEC))<br>        .add_state::&lt;GameState&gt;()<br>        .add_systems(FixedUpdate, update_board.run_if(in_state(GameState::Running)))<br>        .add_systems(Startup, initial_setup)<br>        .add_systems(Update, (button_system, keyboard_system, draw_board).chain())<br>        .run();<br>}<br><br>#[allow(clippy::needless_pass_by_value)]<br>fn initial_setup(mut commands: Commands, board: Res&lt;Board&gt;) {<br>    commands.spawn(Camera2dBundle::default());<br>    //Button style<br>    let button_style = Style {<br>        display: Display::Grid,<br>        justify_content: JustifyContent::Center,<br>        align_items: AlignItems::Center,<br>        ..default()<br>    };<br>    //Draw the grid layout!<br>    commands<br>        .spawn(NodeBundle {<br>            style: Style {<br>                // Create a grid layout, at 100% of the parent element<br>                // Height and width.<br>                display: Display::Grid,<br>                width: Val::Percent(100.0),<br>                height: Val::Percent(100.0),<br>                grid_template_columns: vec![<br>                    GridTrack::auto(); usize::from(board.squares_wide)<br>                ],<br>                grid_template_rows: vec![<br>                    GridTrack::auto(); usize::from(board.squares_high)<br>                ],<br>                ..default()<br>            },<br>            background_color: BackgroundColor(Color::WHITE),<br>            ..default()<br>        })<br>        .with_children(|builder| {<br>            //Every other will be black or white!<br>            for c in 0..board.squares_wide {<br>                for r in 0..board.squares_high {<br>                    let color = if board.squares[usize::from(c)][usize::from(r)] {<br>                        Color::BLACK<br>                    } else {<br>                        Color::WHITE<br>                    };<br>                    let grid_loc = GridLocation {column: c, row: r};<br>                    builder.spawn(<br>                        (ButtonBundle {<br>                            style: button_style.clone(),<br>                            background_color: BackgroundColor(color),<br>                            ..default()<br>                        }, grid_loc)<br>                    );<br>                }<br>            }<br>        });<br>}<br><br>#[allow(clippy::type_complexity)]<br>fn button_system(mut interaction_query: Query&lt;<br>    (<br>        &amp;Interaction,<br>        &amp;GridLocation,<br>    ),<br>    (Changed&lt;Interaction&gt;, With&lt;Button&gt;),<br>&gt;, mut board: ResMut&lt;Board&gt;) {<br>    for (interaction, grid_loc) in &amp;mut interaction_query {<br>        match *interaction {<br>            Interaction::Pressed =&gt; {<br>                let r = usize::from(grid_loc.row);<br>                let c = usize::from(grid_loc.column);<br>                //Get the game state.<br>                let cur = board.squares[c][r];<br>                println!(&quot;Button pressed at ({c},{r}) -- Currently:{cur}&quot;);<br>                board.squares[c][r] = !cur;<br>            },<br>            Interaction::Hovered | Interaction::None =&gt; {},<br>        }<br>    }<br>}<br><br>#[allow(clippy::needless_pass_by_value)]<br>fn keyboard_system(keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;, game_state: Res&lt;State&lt;GameState&gt;&gt;, mut next_game_state: ResMut&lt;NextState&lt;GameState&gt;&gt;, <br>    mut board: ResMut&lt;Board&gt;) {<br>    if keyboard_input.just_pressed(KeyCode::Space) {<br>        match game_state.to_owned() {<br>            GameState::Running =&gt; {<br>                println!(&quot;Pausing&quot;);<br>                next_game_state.set(GameState::Paused);<br>            },<br>            GameState::Paused =&gt; {<br>                println!(&quot;Running&quot;);<br>                next_game_state.set(GameState::Running);<br>            },<br>        }<br>    }<br>    if keyboard_input.just_pressed(KeyCode::C) {<br>        println!(&quot;Clear&quot;);<br>        for c in 0..usize::from(board.squares_wide) {<br>            for r in 0..usize::from(board.squares_high) {<br>                board.squares[c][r] = false;<br>            }<br>        }<br>    }<br>}<br><br>fn update_board(mut query: Query&lt;&amp;GridLocation&gt;, mut board: ResMut&lt;Board&gt;) {<br>    //Fetch the neighbor counts.<br>    let neighbor_counts = get_alive_neighbor_counts(board.as_ref());<br>    for grid_loc in &amp;mut query {<br>        let c = usize::from(grid_loc.column);<br>        let r = usize::from(grid_loc.row);<br>        let cur = board.squares[c][r];<br>        let n = neighbor_counts[c][r];<br>        let mut new_state = cur;<br>        if cur {<br>            // Live cell<br>            //fewer than two live neighbours dies, as if by underpopulation.<br>            if n &lt; 2 {<br>                //Underpop<br>                new_state = false;<br>            }<br>            //two or three live neighbours lives on to the next generation.<br>            if n == 2 || n == 3 {<br>                //We live!<br>                new_state = true;<br>            }<br>            //more than three live neighbours dies, as if by overpopulation.<br>            if n &gt; 3 {<br>                //Overpop<br>                new_state = false;<br>            }<br>        } else {<br>            // Dead Cell<br>            //exactly three live neighbours becomes a live cell, as if by reproduction.<br>            if n == 3 {<br>                //breeeed<br>                new_state = true;<br>            }<br>        }<br>        //Update the data<br>        board.squares[c][r] = new_state;<br>    }<br>}<br><br>#[allow(clippy::needless_pass_by_value)]<br>fn draw_board(mut query: Query&lt;(&amp;mut BackgroundColor, &amp;GridLocation)&gt;, board: Res&lt;Board&gt;) {<br>    for (mut color, grid_loc) in &amp;mut query {<br>        let alive = board.squares[usize::from(grid_loc.column)][usize::from(grid_loc.row)];<br>        if alive {<br>            *color = Color::BLACK.into();<br>        } else {<br>            *color = Color::WHITE.into();<br>        }<br>    }<br>}<br><br>fn get_alive_neighbor_counts(board: &amp;Board) -&gt; Vec&lt;Vec&lt;usize&gt;&gt; {<br>    let height = usize::from(board.squares_high);<br>    let width = usize::from(board.squares_wide);<br>    let mut neighbor_counts = vec![vec![0; height]; width];<br>    for (c, row) in neighbor_counts.iter_mut().enumerate() {<br>        for (r, item) in  row.iter_mut().enumerate() {<br>            let mut neighbors = 0;<br>            //Top<br>            if r &gt; 0 {<br>                //T/L<br>                if c &gt; 0 &amp;&amp; board.squares[c-1][r-1] {<br>                    neighbors += 1;<br>                }<br>                //T/C<br>                if board.squares[c][r-1] {<br>                    neighbors += 1;<br>                }<br>                //T/R<br>                if c+1 &lt; width &amp;&amp; board.squares[c+1][r-1] {<br>                    neighbors += 1;<br>                }<br>            }<br>            //Left<br>            if c &gt; 0 &amp;&amp; board.squares[c-1][r] {<br>                neighbors += 1;<br>            }<br>            //Right<br>            if c+1 &lt; width &amp;&amp; board.squares[c+1][r] {<br>                neighbors += 1;<br>            }<br>            //Bottom<br>            if r+1 &lt; height {<br>                //B/L<br>                if c &gt; 0 &amp;&amp; board.squares[c-1][r+1] {<br>                    neighbors += 1;<br>                }<br>                //B/C<br>                if board.squares[c][r+1] {<br>                    neighbors += 1;<br>                }<br>                //B/R<br>                if c+1 &lt; width &amp;&amp; board.squares[c+1][r+1] {<br>                    neighbors += 1;<br>                }<br>            }<br>            *item = neighbors;<br>        }<br>    }<br>    neighbor_counts<br>}</pre><p>Let‚Äôs commit for good¬†measure!</p><p>git commit -a -m ‚ÄúAdd ability to pause/resume and clear the board. Refactor the UX setting to be contained in the draw_board function.‚Äù</p><h3>Iteration counter¬†display</h3><p>Next it‚Äôd be nice to display a few pieces of info about the game status, like the number of alive or dead squares and the number of iterations since the last start/clear.</p><p>For this we will add additional information into the board resource, and one that represents the current game iteration count. In addition we‚Äôll add some no-member structs we‚Äôll use later when spawning our new text¬†areas.</p><pre>//main.rs<br>//Add alive_squares to the Board.<br>#[derive(Resource)]<br>struct Board {<br>    squares_wide: u16,<br>    squares_high: u16,<br>    squares: Vec&lt;Vec&lt;bool&gt;&gt;,<br>    alive_squares: usize,<br>}<br><br>//Add a new iterations counter to a GameMetadata below board.<br>#[derive(Resource, Default)]<br>struct GameMetadata {<br>    iterations: usize<br>}<br><br>#[derive(Component)]<br>struct IterationText;<br><br>#[derive(Component)]<br>struct GameStateText;<br><br>//main.rs main function<br>// Add the alive_squares to be 1/2 of the cols * rows.<br>let board = Board {squares_wide: cols, squares_high: rows, squares: board_state, alive_squares: usize::from(cols) * usize::from(rows) / 2};<br>let game_metadata = GameMetadata::default();<br>// Add game_metadata after the board insertion.<br>.insert_resource(game_metadata)<br></pre><p>Next we‚Äôll add a new UX element for a status bar at the bottom of the¬†game.</p><p>In the area we already declare some of the consts, add a pixel height of the status bar as well as resize the window to accomodate out new¬†space.</p><pre>//main.rs<br>// Below TITLE_SIZE<br>const STATUS_BAR_PX: f32 = 40.0;<br><br>// In the main function, change the window_height variable to also include the STATUS_BAR_PX<br>let window_width = f32::from(TILE_SIZE * board.squares_wide);<br>let window_height =  f32::from(TILE_SIZE * board.squares_high) + STATUS_BAR_PX;<br>// Update the resolution aspect of the window setting to no longer require f32::from<br>resolution: (window_width, window_height).into(),</pre><p>Previously our game grid layout was added to the base world at 100% height and width, now we need to add an additional status bar below the game grid, so we‚Äôll add another layer of grid layout, this time with 1 column and two rows. In addition, we will use a fixed size for the status bar row, and configure the game grid row to take up all the remaining space (base height <em>minus </em>the fixed number of¬†pixels).</p><p>Here‚Äôs a high level view of what we‚Äôre going to change¬†to.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*YMP9Pnq5PwpZ_Dab7LRnaw.png" /></figure><p>First thing we spawn will be the 1 column, 2 row grid¬†layout.</p><pre>//main.rs<br>//Update initial_setup method signature to also take in the GameMetadata.<br>#[allow(clippy::needless_pass_by_value)]<br>fn initial_setup(mut commands: Commands, board: Res&lt;Board&gt;, metadata: ResMut&lt;GameMetadata&gt;) {<br>//&lt;...&gt;<br>// replace the spawn of the prior game grid layout.<br>    commands<br>        .spawn(NodeBundle {<br>            style: Style {<br>                //Create a grid layout,<br>                display: Display::Grid,<br>                width: Val::Percent(100.0),<br>                height: Val::Percent(100.0),<br>                grid_template_columns: vec![<br>                    GridTrack::auto()<br>                ],<br>                //Top Row will take up all the space after the bottom row is complete.<br>                grid_template_rows: vec![<br>                    GridTrack::flex(1.0), GridTrack::px(STATUS_BAR_PX)<br>                ],<br>                ..default()<br>            },<br>            background_color: BackgroundColor(Color::WHITE),<br>            ..default()<br>        })</pre><p>This grid layout we just added fills 100% of the base and with GridTrack::px we add a fixed element size for the bottom¬†row.</p><p>We then use this to add children to it, which will be the grid layout like before, and a new status bar item with some tuples of TextBundles as well as the components we created¬†above.</p><p>The two new TextBundles will represent the game state (paused, etc) and the iteration count + alive square¬†counts.</p><pre>//main.rs<br>//initial_setup below the new gridlayout.<br>        .with_children(|builder| {<br>            //Game Area<br>            builder.spawn(NodeBundle {<br>                style: Style {<br>                    //Create a grid layout,<br>                    display: Display::Grid,<br>                    width: Val::Percent(100.0),<br>                    height: Val::Percent(100.0),<br>                    grid_template_columns: vec![<br>                        GridTrack::auto(); usize::from(board.squares_wide)<br>                    ],<br>                    grid_template_rows: vec![<br>                        GridTrack::auto(); usize::from(board.squares_high)<br>                    ],<br>                    ..default()<br>                },<br>                background_color: BackgroundColor(Color::WHITE),<br>                ..default()<br>            })<br>            .with_children(|game_area_builder| {<br>                //Every other will be black or white!<br>                for c in 0..board.squares_wide {<br>                    for r in 0..board.squares_high {<br>                        //Set the color based on the board state.<br>                        let color = if board.squares[usize::from(c)][usize::from(r)] {<br>                            Color::BLACK<br>                        } else {<br>                            Color::WHITE<br>                        };<br>                        let grid_loc = GridLocation {column: c, row: r};<br>                        game_area_builder.spawn(<br>                            (ButtonBundle {<br>                                style: button_style.clone(),<br>                                background_color: BackgroundColor(color),<br>                                ..default()<br>                            }, grid_loc)<br>                        );<br>                    }<br>                }<br>            });<br>            //Status Tray<br>            builder.spawn(NodeBundle {<br>                style: Style {<br>                    display: Display::Grid,<br>                    padding: UiRect::all(Val::Px(6.0)),<br>                    grid_template_rows: vec![<br>                        GridTrack::auto()<br>                    ],<br>                    //Left slot, right slot.<br>                    grid_template_columns: vec![<br>                        GridTrack::auto(), GridTrack::auto()<br>                    ],<br>                    ..default()<br>                },<br>                ..default()<br>            })<br>            .with_children(|tray_builder| {<br>                tray_builder.spawn((TextBundle::from_section(<br>                    &quot;Running: [space] to pause, [c] to clear.&quot;,<br>                    TextStyle {<br>                        font: Handle::default(),<br>                        font_size: 20.0,<br>                        color: Color::BLACK,<br>                    },<br>                ), GameStateText));<br>                tray_builder.spawn((TextBundle::from_section(<br>                    format!(&quot;Iter:{}; Alive:{}&quot;, metadata.iterations, board.alive_squares),<br>                    TextStyle {<br>                        font: Handle::default(),<br>                        font_size: 20.0,<br>                        color: Color::BLACK,<br>                    },<br>                ).with_text_alignment(TextAlignment::Right), IterationText));<br>            });<br>        });</pre><p>The reason we added the new IterationText and StatusText components is so we can query for these specific text fields when we want to update their values after the game is paused or an iteration tick occurred. For this text update we‚Äôll add a new system. This new system queries for any Text element with IterationText associated to modify the text on iteration update.</p><p>For the status_bar_text_update we require the two Text entities as the query params, one for the GameStateText and the other for IterationText. If we just add two different query params Bevy prevents it. This is because Bevy has no guarantee we didn‚Äôt create entities that may share a Component. If we has added both GameStateText and IterationText we would have two mutable references to the same variable which would violate the guarantees of safe¬†rust.</p><p>The solution to this is the <a href="https://docs.rs/bevy/latest/bevy/prelude/struct.ParamSet.html">ParamSet</a> which uses parameter numbering and the borrow checker to ensure we only have a mutable reference to one of the parameters at a time. There are some pretty good examples and explanations in the <a href="https://docs.rs/bevy/latest/bevy/prelude/struct.ParamSet.html">ParamSet</a>¬†docs.</p><pre>//main.rs<br>// Below the keyboard system<br>#[allow(clippy::type_complexity, clippy::needless_pass_by_value)]<br>fn status_bar_text_update(mut text_params: ParamSet&lt;(Query&lt;&amp;mut Text, With&lt;GameStateText&gt;&gt;, Query&lt;&amp;mut Text, With&lt;IterationText&gt;&gt;)&gt;, board: Res&lt;Board&gt;,<br>    metadata: Res&lt;GameMetadata&gt;, game_state: Res&lt;State&lt;GameState&gt;&gt;) {<br>    let mut game_state_query = text_params.p0();<br>    match game_state.to_owned() {<br>        GameState::Running =&gt; {<br>            game_state_query.single_mut().sections[0].value = &quot;Running: [space] to pause, [c] to clear.&quot;.to_string();<br>        },<br>        GameState::Paused =&gt; {<br>            game_state_query.single_mut().sections[0].value = &quot;Paused: [space] to resume, [c] to clear, [n] for next.&quot;.to_string();<br>        },<br>    }<br>    let mut iter_state_query = text_params.p1();<br>    let new_text = format!(&quot;Iter:{}; Alive:{}&quot;, metadata.iterations, board.alive_squares);<br>    iter_state_query.single_mut().sections[0].value = new_text;<br>}<br>// in main() where the systems are intitialized, update the Update system addition<br>.add_systems(Update, (button_system, keyboard_system, draw_board, status_bar_text_update).chain())<br></pre><p>We also have to change the square count and increment the iteration counter in both update_board, the keyboard_system, and button_system functions.</p><pre>//main.rs<br>// Add the new metadata resource to update_board.<br>// Count up the alive squares and increment the iterations.<br>fn update_board(mut query: Query&lt;&amp;GridLocation&gt;, mut board: ResMut&lt;Board&gt;, mut metadata: ResMut&lt;GameMetadata&gt;) {<br>    //Fetch the neighbor counts.<br>    let neighbor_counts = get_alive_neighbor_counts(board.as_ref());<br>    let mut alive_count = 0;<br>    for grid_loc in &amp;mut query {<br>        let c = usize::from(grid_loc.column);<br>        let r = usize::from(grid_loc.row);<br>        let cur = board.squares[c][r];<br>        let n = neighbor_counts[c][r];<br>        let mut new_state = cur;<br>        if cur {<br>            // Live cell<br>            //fewer than two live neighbours dies, as if by underpopulation.<br>            if n &lt; 2 {<br>                //Underpop<br>                new_state = false;<br>            }<br>            //two or three live neighbours lives on to the next generation.<br>            if n == 2 || n == 3 {<br>                //We live!<br>                new_state = true;<br>            }<br>            //more than three live neighbours dies, as if by overpopulation.<br>            if n &gt; 3 {<br>                //Overpop<br>                new_state = false;<br>            }<br>        } else {<br>            // Dead Cell<br>            //exactly three live neighbours becomes a live cell, as if by reproduction.<br>            if n == 3 {<br>                //breeeed<br>                new_state = true;<br>            }<br>        }<br>        if new_state {<br>            alive_count += 1;<br>        }<br>        //Update the data<br>        board.squares[c][r] = new_state;<br>    }<br>    board.alive_squares = alive_count;<br>    metadata.iterations += 1;<br>}<br><br>//Modify the button system to mod the alive count<br>#[allow(clippy::type_complexity)]<br>fn button_system(mut interaction_query: Query&lt;<br>    (<br>        &amp;Interaction,<br>        &amp;GridLocation,<br>    ),<br>    (Changed&lt;Interaction&gt;, With&lt;Button&gt;),<br>&gt;, mut board: ResMut&lt;Board&gt;) {<br>    for (interaction, grid_loc) in &amp;mut interaction_query {<br>        match *interaction {<br>            Interaction::Pressed =&gt; {<br>                let r = usize::from(grid_loc.row);<br>                let c = usize::from(grid_loc.column);<br>                //Get the game state.<br>                let cur = board.squares[c][r];<br>                if cur {<br>                    board.alive_squares -= 1;<br>                } else {<br>                    board.alive_squares += 1;<br>                }<br>                println!(&quot;Button pressed at ({c},{r}) -- Currently:{cur}&quot;);<br>                board.squares[c][r] = !cur;<br>            },<br>            Interaction::Hovered | Interaction::None =&gt; {},<br>        }<br>    }<br>}<br><br>//And the keyboard_system to zero the alive_squares on clear.<br>#[allow(clippy::needless_pass_by_value)]<br>fn keyboard_system(keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;, game_state: Res&lt;State&lt;GameState&gt;&gt;, mut next_game_state: ResMut&lt;NextState&lt;GameState&gt;&gt;, <br>    mut board: ResMut&lt;Board&gt;) {<br>    if keyboard_input.just_pressed(KeyCode::Space) {<br>        match game_state.to_owned() {<br>            GameState::Running =&gt; {<br>                println!(&quot;Pausing&quot;);<br>                next_game_state.set(GameState::Paused);<br>            },<br>            GameState::Paused =&gt; {<br>                println!(&quot;Running&quot;);<br>                next_game_state.set(GameState::Running);<br>            },<br>        }<br>    }<br>    if keyboard_input.just_pressed(KeyCode::C) {<br>        println!(&quot;Clear&quot;);<br>        for c in 0..usize::from(board.squares_wide) {<br>            for r in 0..usize::from(board.squares_high) {<br>                board.squares[c][r] = false;<br>            }<br>        }<br>        board.alive_squares = 0;<br>    }<br>}</pre><p>Okay now, lots of additions scattered everywhere on that one, let‚Äôs do another full¬†main.rs</p><pre>//main.rs<br>#![warn(clippy::pedantic)]<br><br>use bevy::prelude::*;<br><br>//Default for the tile sizes.<br>const TILE_SIZE: u16 = 40;<br>const STATUS_BAR_PX: f32 = 40.0;<br>const UPDATE_RATE_SEC: f64 = 0.5;<br><br>#[derive(Debug, Default, Clone, Eq, PartialEq, Hash, States)]<br>enum GameState {<br>    #[default]<br>    Running,<br>    Paused,<br>}<br><br>#[derive(Resource)]<br>struct Board {<br>    squares_wide: u16,<br>    squares_high: u16,<br>    squares: Vec&lt;Vec&lt;bool&gt;&gt;,<br>    alive_squares: usize,<br>}<br><br>#[derive(Resource, Default)]<br>struct GameMetadata {<br>    iterations: usize<br>}<br><br>#[derive(Component)]<br>struct IterationText;<br><br>#[derive(Component)]<br>struct GameStateText;<br><br>#[derive(Component, Debug)]<br>struct GridLocation {<br>    row: u16,<br>    column: u16<br>}<br><br>fn main() {<br>    println!(&quot;Bevy app starting!&quot;);<br>    let cols = 20;<br>    let rows = 20;<br>    // Create a 2d vector where every other square is on or off.<br>    // This is equivalent to a nested for loop over cols then row elements.<br>    let board_state = (0..cols).map(|col| <br>        (0..rows).map(|row| <br>            (col + row) % 2 == 0)<br>            .collect())<br>    .collect();<br>    let board = Board {squares_wide: cols, squares_high: rows, squares: board_state, alive_squares: usize::from(cols) * usize::from(rows) / 2};<br>    let game_metadata = GameMetadata::default();<br>    let window_width = f32::from(TILE_SIZE * board.squares_wide);<br>    let window_height =  f32::from(TILE_SIZE * board.squares_high) + STATUS_BAR_PX;<br>    App::new()<br>        .add_plugins(<br>            DefaultPlugins.set(WindowPlugin {<br>                primary_window: Some(Window {<br>                    title: &quot;Conway&#39;s Game of Life&quot;.into(),<br>                    resolution: (window_width, window_height).into(),<br>                    ..default()<br>                }),<br>                ..default()<br>            })<br>        )<br>        .insert_resource(board)<br>        .insert_resource(game_metadata)<br>        .insert_resource(Time::&lt;Fixed&gt;::from_seconds(UPDATE_RATE_SEC))<br>        .add_state::&lt;GameState&gt;()<br>        .add_systems(FixedUpdate, update_board.run_if(in_state(GameState::Running)))<br>        .add_systems(Startup, initial_setup)<br>        .add_systems(Update, (button_system, keyboard_system, draw_board, status_bar_text_update).chain())<br>        .run();<br>}<br><br>#[allow(clippy::needless_pass_by_value)]<br>fn initial_setup(mut commands: Commands, board: Res&lt;Board&gt;, metadata: ResMut&lt;GameMetadata&gt;) {<br>    commands.spawn(Camera2dBundle::default());<br>    //Button style<br>    let button_style = Style {<br>        display: Display::Grid,<br>        justify_content: JustifyContent::Center,<br>        align_items: AlignItems::Center,<br>        ..default()<br>    };<br>    //Draw the grid layout!<br>    commands<br>        .spawn(NodeBundle {<br>            style: Style {<br>                //Create a grid layout,<br>                display: Display::Grid,<br>                width: Val::Percent(100.0),<br>                height: Val::Percent(100.0),<br>                grid_template_columns: vec![<br>                    GridTrack::auto()<br>                ],<br>                //Top Row will take up all the space after the bottom row is complete.<br>                grid_template_rows: vec![<br>                    GridTrack::flex(1.0), GridTrack::px(STATUS_BAR_PX)<br>                ],<br>                ..default()<br>            },<br>            background_color: BackgroundColor(Color::WHITE),<br>            ..default()<br>        })<br>        .with_children(|builder| {<br>            //Game Area<br>            builder.spawn(NodeBundle {<br>                style: Style {<br>                    //Create a grid layout,<br>                    display: Display::Grid,<br>                    width: Val::Percent(100.0),<br>                    height: Val::Percent(100.0),<br>                    grid_template_columns: vec![<br>                        GridTrack::auto(); usize::from(board.squares_wide)<br>                    ],<br>                    grid_template_rows: vec![<br>                        GridTrack::auto(); usize::from(board.squares_high)<br>                    ],<br>                    ..default()<br>                },<br>                background_color: BackgroundColor(Color::WHITE),<br>                ..default()<br>            })<br>            .with_children(|game_area_builder| {<br>                //Every other will be black or white!<br>                for c in 0..board.squares_wide {<br>                    for r in 0..board.squares_high {<br>                        //Set the color based on the board state.<br>                        let color = if board.squares[usize::from(c)][usize::from(r)] {<br>                            Color::BLACK<br>                        } else {<br>                            Color::WHITE<br>                        };<br>                        let grid_loc = GridLocation {column: c, row: r};<br>                        game_area_builder.spawn(<br>                            (ButtonBundle {<br>                                style: button_style.clone(),<br>                                background_color: BackgroundColor(color),<br>                                ..default()<br>                            }, grid_loc)<br>                        );<br>                    }<br>                }<br>            });<br>            //Status Tray<br>            builder.spawn(NodeBundle {<br>                style: Style {<br>                    display: Display::Grid,<br>                    padding: UiRect::all(Val::Px(6.0)),<br>                    grid_template_rows: vec![<br>                        GridTrack::auto()<br>                    ],<br>                    //Left slot, right slot.<br>                    grid_template_columns: vec![<br>                        GridTrack::auto(), GridTrack::auto()<br>                    ],<br>                    ..default()<br>                },<br>                ..default()<br>            })<br>            .with_children(|tray_builder| {<br>                tray_builder.spawn((TextBundle::from_section(<br>                    &quot;Running: [space] to pause, [c] to clear.&quot;,<br>                    TextStyle {<br>                        font: Handle::default(),<br>                        font_size: 20.0,<br>                        color: Color::BLACK,<br>                    },<br>                ), GameStateText));<br>                tray_builder.spawn((TextBundle::from_section(<br>                    format!(&quot;Iter:{}; Alive:{}&quot;, metadata.iterations, board.alive_squares),<br>                    TextStyle {<br>                        font: Handle::default(),<br>                        font_size: 20.0,<br>                        color: Color::BLACK,<br>                    },<br>                ).with_text_alignment(TextAlignment::Right), IterationText));<br>            });<br>        });<br>}<br><br>#[allow(clippy::type_complexity)]<br>fn button_system(mut interaction_query: Query&lt;<br>    (<br>        &amp;Interaction,<br>        &amp;GridLocation,<br>    ),<br>    (Changed&lt;Interaction&gt;, With&lt;Button&gt;),<br>&gt;, mut board: ResMut&lt;Board&gt;) {<br>    for (interaction, grid_loc) in &amp;mut interaction_query {<br>        match *interaction {<br>            Interaction::Pressed =&gt; {<br>                let r = usize::from(grid_loc.row);<br>                let c = usize::from(grid_loc.column);<br>                //Get the game state.<br>                let cur = board.squares[c][r];<br>                if cur {<br>                    board.alive_squares -= 1;<br>                } else {<br>                    board.alive_squares += 1;<br>                }<br>                println!(&quot;Button pressed at ({c},{r}) -- Currently:{cur}&quot;);<br>                board.squares[c][r] = !cur;<br>            },<br>            Interaction::Hovered | Interaction::None =&gt; {},<br>        }<br>    }<br>}<br><br>#[allow(clippy::needless_pass_by_value)]<br>fn keyboard_system(keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;, game_state: Res&lt;State&lt;GameState&gt;&gt;, mut next_game_state: ResMut&lt;NextState&lt;GameState&gt;&gt;, <br>    mut board: ResMut&lt;Board&gt;) {<br>    if keyboard_input.just_pressed(KeyCode::Space) {<br>        match game_state.to_owned() {<br>            GameState::Running =&gt; {<br>                println!(&quot;Pausing&quot;);<br>                next_game_state.set(GameState::Paused);<br>            },<br>            GameState::Paused =&gt; {<br>                println!(&quot;Running&quot;);<br>                next_game_state.set(GameState::Running);<br>            },<br>        }<br>    }<br>    if keyboard_input.just_pressed(KeyCode::C) {<br>        println!(&quot;Clear&quot;);<br>        for c in 0..usize::from(board.squares_wide) {<br>            for r in 0..usize::from(board.squares_high) {<br>                board.squares[c][r] = false;<br>            }<br>        }<br>        board.alive_squares = 0;<br>    }<br>}<br><br>#[allow(clippy::type_complexity, clippy::needless_pass_by_value)]<br>fn status_bar_text_update(mut text_params: ParamSet&lt;(Query&lt;&amp;mut Text, With&lt;GameStateText&gt;&gt;, Query&lt;&amp;mut Text, With&lt;IterationText&gt;&gt;)&gt;, board: Res&lt;Board&gt;,<br>    metadata: Res&lt;GameMetadata&gt;, game_state: Res&lt;State&lt;GameState&gt;&gt;) {<br>    let mut game_state_query = text_params.p0();<br>    match game_state.to_owned() {<br>        GameState::Running =&gt; {<br>            game_state_query.single_mut().sections[0].value = &quot;Running: [space] to pause, [c] to clear.&quot;.to_string();<br>        },<br>        GameState::Paused =&gt; {<br>            game_state_query.single_mut().sections[0].value = &quot;Paused: [space] to resume, [c] to clear, [n] for next.&quot;.to_string();<br>        },<br>    }<br>    let mut iter_state_query = text_params.p1();<br>    let new_text = format!(&quot;Iter:{}; Alive:{}&quot;, metadata.iterations, board.alive_squares);<br>    iter_state_query.single_mut().sections[0].value = new_text;<br>}<br><br>fn update_board(mut query: Query&lt;&amp;GridLocation&gt;, mut board: ResMut&lt;Board&gt;, mut metadata: ResMut&lt;GameMetadata&gt;) {<br>    //Fetch the neighbor counts.<br>    let neighbor_counts = get_alive_neighbor_counts(board.as_ref());<br>    let mut alive_count = 0;<br>    for grid_loc in &amp;mut query {<br>        let c = usize::from(grid_loc.column);<br>        let r = usize::from(grid_loc.row);<br>        let cur = board.squares[c][r];<br>        let n = neighbor_counts[c][r];<br>        let mut new_state = cur;<br>        if cur {<br>            // Live cell<br>            //fewer than two live neighbours dies, as if by underpopulation.<br>            if n &lt; 2 {<br>                //Underpop<br>                new_state = false;<br>            }<br>            //two or three live neighbours lives on to the next generation.<br>            if n == 2 || n == 3 {<br>                //We live!<br>                new_state = true;<br>            }<br>            //more than three live neighbours dies, as if by overpopulation.<br>            if n &gt; 3 {<br>                //Overpop<br>                new_state = false;<br>            }<br>        } else {<br>            // Dead Cell<br>            //exactly three live neighbours becomes a live cell, as if by reproduction.<br>            if n == 3 {<br>                //breeeed<br>                new_state = true;<br>            }<br>        }<br>        if new_state {<br>            alive_count += 1;<br>        }<br>        //Update the data<br>        board.squares[c][r] = new_state;<br>    }<br>    board.alive_squares = alive_count;<br>    metadata.iterations += 1;<br>}<br><br>#[allow(clippy::needless_pass_by_value)]<br>fn draw_board(mut query: Query&lt;(&amp;mut BackgroundColor, &amp;GridLocation)&gt;, board: Res&lt;Board&gt;) {<br>    for (mut color, grid_loc) in &amp;mut query {<br>        let alive = board.squares[usize::from(grid_loc.column)][usize::from(grid_loc.row)];<br>        if alive {<br>            *color = Color::BLACK.into();<br>        } else {<br>            *color = Color::WHITE.into();<br>        }<br>    }<br>}<br><br>fn get_alive_neighbor_counts(board: &amp;Board) -&gt; Vec&lt;Vec&lt;usize&gt;&gt; {<br>    let height = usize::from(board.squares_high);<br>    let width = usize::from(board.squares_wide);<br>    let mut neighbor_counts = vec![vec![0; height]; width];<br>    for (c, row) in neighbor_counts.iter_mut().enumerate() {<br>        for (r, item) in  row.iter_mut().enumerate() {<br>            let mut neighbors = 0;<br>            //Top<br>            if r &gt; 0 {<br>                //T/L<br>                if c &gt; 0 &amp;&amp; board.squares[c-1][r-1] {<br>                    neighbors += 1;<br>                }<br>                //T/C<br>                if board.squares[c][r-1] {<br>                    neighbors += 1;<br>                }<br>                //T/R<br>                if c+1 &lt; width &amp;&amp; board.squares[c+1][r-1] {<br>                    neighbors += 1;<br>                }<br>            }<br>            //Left<br>            if c &gt; 0 &amp;&amp; board.squares[c-1][r] {<br>                neighbors += 1;<br>            }<br>            //Right<br>            if c+1 &lt; width &amp;&amp; board.squares[c+1][r] {<br>                neighbors += 1;<br>            }<br>            //Bottom<br>            if r+1 &lt; height {<br>                //B/L<br>                if c &gt; 0 &amp;&amp; board.squares[c-1][r+1] {<br>                    neighbors += 1;<br>                }<br>                //B/C<br>                if board.squares[c][r+1] {<br>                    neighbors += 1;<br>                }<br>                //B/R<br>                if c+1 &lt; width &amp;&amp; board.squares[c+1][r+1] {<br>                    neighbors += 1;<br>                }<br>            }<br>            *item = neighbors;<br>        }<br>    }<br>    neighbor_counts<br>}</pre><p>Now let‚Äôs see this bad-boy in¬†action!</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/796/1*cMR4gik6lfSvNfUlaobTfQ.gif" /></figure><p>git commit -a -m ‚ÄúAdd status bar with iterations, gamestate, and alive square¬†count.‚Äù</p><h3>Event Triggering</h3><p>I added some counters on our systems to show how often an iteration ticks against the number of draw calls we execute‚Ä¶.</p><pre>Draw count:225 iterations:9<br>Draw count:251 iterations:10<br>Draw count:277 iterations:11<br>Draw count:303 iterations:12</pre><p>Whoa, this means for every iteration we execute, we have drawn the board about <strong><em>25</em></strong> times! <strong>Most </strong>of these will be draws that were already present, so wouldn‚Äôt it be nice if we only drew the board when we need¬†to??</p><p>The naive approach might be to only do draw_board with the FixedUpdate schedule after we call update_board on, but there are a few issues with that approach:</p><ol><li>update_board only executes when the game is running, so if we were paused, we would only see the results of mouse clicks after the game is¬†resumed.</li><li>Due to the fixed update nature of update_board, our clicks to the screen will be delayed until up to 1/2 sec after we click. This would make the user-input feel sluggish.</li></ol><p>Luckily Bevy includes an Event feature specifically for this‚Ää‚Äî‚ÄäWe‚Äôll add various event types to represent which areas need to be redrawn, then we can fire off a redraw event from the mouse, keyboard, or fixed rate update_board functions.</p><p>Events in bevy are sent with an <a href="https://docs.rs/bevy/latest/bevy/prelude/struct.EventWriter.html">EventWriter </a>and read via‚Ä¶ you guessed it, an <a href="https://docs.rs/bevy/latest/bevy/prelude/struct.EventReader.html">EventReader</a>! The events can be sent from any system and are passed into the system functions like other parameters once registered to the¬†app.</p><p>A Bevy event can contain custom data, but for our use, we just want them to be a signal to execute some work. For this, we‚Äôll add some new structs with the Event &amp; Default traits¬†derived.</p><pre>//main.rs<br>// below GridLocation<br>#[derive(Event, Default)]<br>struct BoardNeedsUpdateEvent;<br><br>#[derive(Event, Default)]<br>struct BoardNeedsDrawingEvent;<br><br>#[derive(Event, Default)]<br>struct StatusBarNeedsDrawingEvent;</pre><p>These three events will be fired when the board needs to be updated (like on a fixed time click), when the board needs to be redrawn in response to a change, and when the status bar needs an update. We could probably merge the board draw event with the status bar draw event, but it doesn‚Äôt hurt much to keep ‚Äòem separate.</p><p>Now we will add a new game_tick_timer function to execute on a fixed time schedule (like update_board previously).</p><pre>//main.rs<br>// before button_system<br>fn game_tick_timer(mut game_board_update_needed: EventWriter&lt;BoardNeedsUpdateEvent&gt;) {<br>    game_board_update_needed.send_default();<br>}</pre><p>Now that we have this new function, let‚Äôs change it to fire on the fixed schedule instead of update_board. We‚Äôll also move update_board to execute on the update schedule so we can pick up events in the same cycle as they are fired off. We also need to add the events in a similar fashion as the resources.</p><pre>//main.rs<br>// main() function new App initialize block:<br>     App::new()<br>        .add_plugins(<br>            DefaultPlugins.set(WindowPlugin {<br>                primary_window: Some(Window {<br>                    title: &quot;Conway&#39;s Game of Life&quot;.into(),<br>                    resolution: (window_width, window_height).into(),<br>                    ..default()<br>                }),<br>                ..default()<br>            })<br>        )<br>        .insert_resource(board)<br>        .insert_resource(game_metadata)<br>        .insert_resource(Time::&lt;Fixed&gt;::from_seconds(UPDATE_RATE_SEC))<br>        .add_event::&lt;BoardNeedsUpdateEvent&gt;()<br>        .add_event::&lt;BoardNeedsDrawingEvent&gt;()<br>        .add_event::&lt;StatusBarNeedsDrawingEvent&gt;()<br>        .add_state::&lt;GameState&gt;()<br>        .add_systems(FixedUpdate, game_tick_timer.run_if(in_state(GameState::Running)))<br>        .add_systems(Startup, initial_setup)<br>        .add_systems(Update, (button_system, keyboard_system, update_board, draw_board, status_bar_text_update).chain())<br>        .run();<br></pre><p>This is where the strict system ordering comes in very handy as we can fire off an event in response to a mouse click or keyboard press and pick up that event in the later functions that execute on the same game¬†cycle.</p><p>Now we‚Äôll update our keyboard and mouse systems to fire off some events on the appropriate changes. Some updates require a board redraw, while others need to update the status¬†bar.</p><p>Update the keyboard system to take all three event writers in and fire off the events when the appropriate key is pressed. We also prune out the status bar update from being directly in the keyboard system to have better duty separation.</p><pre>//main.rs<br>//Update button_system<br>#[allow(clippy::type_complexity)]<br>fn button_system(mut interaction_query: Query&lt;<br>    (<br>        &amp;Interaction,<br>        &amp;GridLocation,<br>    ),<br>    (Changed&lt;Interaction&gt;, With&lt;Button&gt;),<br>&gt;, mut board: ResMut&lt;Board&gt;, mut board_needs_drawing: EventWriter&lt;BoardNeedsDrawingEvent&gt;,<br>    mut status_bar_needs_update: EventWriter&lt;StatusBarNeedsDrawingEvent&gt;) {<br>    for (interaction, grid_loc) in &amp;mut interaction_query {<br>        match *interaction {<br>            Interaction::Pressed =&gt; {<br>                let r = grid_loc.row;<br>                let c = grid_loc.column;<br>                //Get the game state.<br>                let cur = board.squares[c][r];<br>                println!(&quot;Button pressed at ({c},{r}) -- Currently:{cur}&quot;);<br>                if cur {<br>                    board.alive_squares -= 1;<br>                } else {<br>                    board.alive_squares += 1;<br>                }<br>                board.squares[c][r] = !cur;<br>                board_needs_drawing.send_default();<br>                status_bar_needs_update.send_default();<br>            },<br>            Interaction::Hovered | Interaction::None =&gt; {},<br>        }<br>    }<br>}<br><br>#[allow(clippy::needless_pass_by_value)]<br>fn keyboard_system(keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;, game_state: Res&lt;State&lt;GameState&gt;&gt;, mut next_game_state: ResMut&lt;NextState&lt;GameState&gt;&gt;,<br>    mut board: ResMut&lt;Board&gt;, mut board_needs_drawing_events: EventWriter&lt;BoardNeedsDrawingEvent&gt;,<br>    mut board_update_events: EventWriter&lt;BoardNeedsUpdateEvent&gt;, mut status_bar_needs_redraw: EventWriter&lt;StatusBarNeedsDrawingEvent&gt;) {<br>    if keyboard_input.just_pressed(KeyCode::Space) {<br>        match game_state.to_owned() {<br>            GameState::Running =&gt; {<br>                next_game_state.set(GameState::Paused);<br>            },<br>            GameState::Paused =&gt; {<br>                next_game_state.set(GameState::Running);<br>            },<br>        }<br>        status_bar_needs_redraw.send_default();<br>    }<br>    if keyboard_input.just_pressed(KeyCode::C) {<br>        println!(&quot;Clear&quot;);<br>        for c in 0..board.squares_wide {<br>            for r in 0..board.squares_high {<br>                board.squares[c][r] = false;<br>            }<br>        }<br>        board.alive_squares = 0;<br>        board_needs_drawing_events.send_default();<br>        status_bar_needs_redraw.send_default();<br>    }<br>    if keyboard_input.just_pressed(KeyCode::N) {<br>        println!(&quot;Next&quot;);<br>        //Send an update to update the board state, including the iterations.<br>        if game_state.to_owned() == GameState::Paused {<br>            board_update_events.send_default();<br>        } else {<br>            println!(&quot;Next disabled when not paused.&quot;);<br>        } <br>    }<br>}</pre><p>Keen readers will notice I snuck a new function into our program‚Ää‚Äî‚ÄäWhen paused, we can now hit <strong>n</strong> to move to the next board state! This addition was super easy due to the event system, and is core to why we created the new game_tick_timer function instead of leaving update_board on a schedule.</p><p>Now, we‚Äôll gate our first function on the presence of an event in the queue. We return early if we don‚Äôt have any event available to¬†process.</p><p>We also need to update our status bar updater to also update the pause/resume message based on the <em>next </em>game state, as we had a minor bug in the prior version as the update lagged by one¬†frame.</p><pre>//main.rs<br>// Change GameState to be the next one, gate the execution of the function on an event,<br>// Change the Pause text to also include &#39;N&#39; key instructions.<br>#[allow(clippy::type_complexity, clippy::needless_pass_by_value)]<br>fn status_bar_text_update(mut text_params: ParamSet&lt;(Query&lt;&amp;mut Text, With&lt;GameStateText&gt;&gt;, Query&lt;&amp;mut Text, With&lt;IterationText&gt;&gt;)&gt;, board: Res&lt;Board&gt;,<br>    metadata: Res&lt;GameMetadata&gt;, next_game_state: Res&lt;NextState&lt;GameState&gt;&gt;, mut status_bar_needs_redraw: EventReader&lt;StatusBarNeedsDrawingEvent&gt;) {<br>    if status_bar_needs_redraw.is_empty() {<br>        return;<br>    }<br>    status_bar_needs_redraw.clear();<br>    <br>    let game_state = next_game_state.0.as_ref().unwrap_or(&amp;GameState::Running);<br>    let mut game_state_query = text_params.p0();<br>    match game_state {<br>        GameState::Running =&gt; {<br>            game_state_query.single_mut().sections[0].value = &quot;Running: [space] to pause, [c] to clear.&quot;.to_string();<br>        },<br>        GameState::Paused =&gt; {<br>            game_state_query.single_mut().sections[0].value = &quot;Paused: [space] to resume, [c] to clear, [n] for next.&quot;.to_string();<br>        },<br>    }<br>    let mut iter_state_query = text_params.p1();<br>    let new_text = format!(&quot;Iter:{}; Alive:{}&quot;, metadata.iterations, board.alive_squares);<br>    iter_state_query.single_mut().sections[0].value = new_text;<br>}</pre><p>Now we‚Äôll gate update_board on the event reader, but also pass in the event writers for both draw event types. <em>As a side note: </em>We should have all event writers generally execute before the event reads may check for the¬†events.</p><pre>//main.rs<br>fn update_board(mut query: Query&lt;&amp;GridLocation&gt;, mut board: ResMut&lt;Board&gt;, mut metadata: ResMut&lt;GameMetadata&gt;,<br>    mut board_update_events: EventReader&lt;BoardNeedsUpdateEvent&gt;, mut board_needs_draw_event: EventWriter&lt;BoardNeedsDrawingEvent&gt;,<br>    mut status_bar_needs_update: EventWriter&lt;StatusBarNeedsDrawingEvent&gt;) {<br>    if board_update_events.is_empty() {<br>        return;<br>    }<br>    board_update_events.clear();<br>    //&lt;...&gt;<br>    //After we increment metadata, fire off two events.<br>    board_needs_draw_event.send_default();<br>    status_bar_needs_update.send_default();<br>}</pre><p>We also need to gate draw_board.</p><pre>//main.rs<br>// Update to draw_board to do work on event presence.<br>#[allow(clippy::needless_pass_by_value)]<br>fn draw_board(mut query: Query&lt;(&amp;mut BackgroundColor, &amp;GridLocation)&gt;, board: Res&lt;Board&gt;, mut board_needs_draw_events: EventReader&lt;BoardNeedsDrawingEvent&gt;) {<br>    if board_needs_draw_events.is_empty() {<br>        return;<br>    }<br>    board_needs_draw_events.clear();<br>//</pre><p>(Full main.rs after the next¬†section)</p><p>Fantastic, we now have an event system that will only execute our more expensive operations like a redraw when updates are necessary.</p><p>Commitments are useful! git commit -a -m ‚ÄúAdd event based board updates, board drawing, and status bar updates.‚Äù</p><h3>Kick it up to 11 (Home stretch¬†now)</h3><p>Ok, so far we‚Äôve had a pretty small 20x20 game board‚Ää‚Äî‚Äälet‚Äôs kick it up a notch! We‚Äôll reduce the square size and bump the board to¬†100x100.</p><pre>//main.rs<br>//Update the TILE_SIZE<br>const TILE_SIZE: u16 = 8;<br><br>//Update the game board size in main()<br>let cols = 100;<br>let rows = 100;</pre><p>When you execute cargo run you may notice the game running a bit slower‚Ä¶ And on modern PCs that seems odd‚Ä¶ it‚Äôs only 10,000 squares to run a sim on‚Ä¶ it certainly should be able to handle¬†it.</p><p>The primary reason is Bevy runs <strong><em>very </em></strong>slowly when it‚Äôs debug variant is built, so we want to add some optimization for it (and other dependencies).</p><p>Add this to the bottom of your Cargo.toml file and we should be back to a 1/2 second tick¬†time.</p><pre>//Cargo.toml<br>//After [dependencies] block.<br><br># Enable max optimizations for dependencies, but not for our code:<br>[profile.dev.package.&quot;*&quot;]<br>opt-level = 3</pre><p>Now, run a cargo clean and a cargo build you may notice some steam coming from your PC while it compiles and optimizes the bevy dependencies. This was the first time outside of a AAA game I had heard my CPU fan kick into high¬†gear.</p><p>Now if we run cargo run it has some very interesting patterns with the larger¬†board!</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/796/1*-IMUqMNqwN849cO6_jimHg.gif" /></figure><p>And now, the final full¬†main.rs</p><pre>//main.rs<br>#![warn(clippy::pedantic)]<br><br>use bevy::prelude::*;<br><br>//Default for the tile sizes.<br>const TILE_SIZE: u16 = 8;<br>const STATUS_BAR_PX: f32 = 40.0;<br>const UPDATE_RATE_SEC: f64 = 0.1;<br><br>#[derive(Debug, Default, Clone, Eq, PartialEq, Hash, States)]<br>enum GameState {<br>    #[default]<br>    Running,<br>    Paused,<br>}<br><br>#[derive(Resource)]<br>struct Board {<br>    squares_wide: u16,<br>    squares_high: u16,<br>    squares: Vec&lt;Vec&lt;bool&gt;&gt;,<br>    alive_squares: usize,<br>}<br><br>#[derive(Resource, Default)]<br>struct GameMetadata {<br>    iterations: usize<br>}<br><br>#[derive(Component)]<br>struct IterationText;<br><br>#[derive(Component)]<br>struct GameStateText;<br><br>#[derive(Component, Debug)]<br>struct GridLocation {<br>    row: u16,<br>    column: u16<br>}<br><br>#[derive(Event, Default)]<br>struct BoardNeedsUpdateEvent;<br><br>#[derive(Event, Default)]<br>struct BoardNeedsDrawingEvent;<br><br>#[derive(Event, Default)]<br>struct StatusBarNeedsDrawingEvent;<br><br>fn main() {<br>    println!(&quot;Bevy app starting!&quot;);<br>    let cols = 100;<br>    let rows = 100;<br>    // Create a 2d vector where every other square is on or off.<br>    // This is equivalent to a nested for loop over cols then row elements.<br>    let board_state = (0..cols).map(|col| <br>        (0..rows).map(|row| <br>            (col + row) % 2 == 0)<br>            .collect())<br>    .collect();<br>    let board = Board {squares_wide: cols, squares_high: rows, squares: board_state, alive_squares: usize::from(cols) * usize::from(rows) / 2};<br>    let game_metadata = GameMetadata::default();<br>    let window_width = f32::from(TILE_SIZE * board.squares_wide);<br>    let window_height =  f32::from(TILE_SIZE * board.squares_high) + STATUS_BAR_PX;<br>    App::new()<br>        .add_plugins(<br>            DefaultPlugins.set(WindowPlugin {<br>                primary_window: Some(Window {<br>                    title: &quot;Conway&#39;s Game of Life&quot;.into(),<br>                    resolution: (window_width, window_height).into(),<br>                    ..default()<br>                }),<br>                ..default()<br>            })<br>        )<br>        .insert_resource(board)<br>        .insert_resource(game_metadata)<br>        .insert_resource(Time::&lt;Fixed&gt;::from_seconds(UPDATE_RATE_SEC))<br>        .add_event::&lt;BoardNeedsUpdateEvent&gt;()<br>        .add_event::&lt;BoardNeedsDrawingEvent&gt;()<br>        .add_event::&lt;StatusBarNeedsDrawingEvent&gt;()<br>        .add_state::&lt;GameState&gt;()<br>        .add_systems(FixedUpdate, game_tick_timer.run_if(in_state(GameState::Running)))<br>        .add_systems(Startup, initial_setup)<br>        .add_systems(Update, (button_system, keyboard_system, update_board, draw_board, status_bar_text_update).chain())<br>        .run();<br>}<br><br>#[allow(clippy::needless_pass_by_value)]<br>fn initial_setup(mut commands: Commands, board: Res&lt;Board&gt;, metadata: ResMut&lt;GameMetadata&gt;) {<br>    commands.spawn(Camera2dBundle::default());<br>    //Button style<br>    let button_style = Style {<br>        display: Display::Grid,<br>        justify_content: JustifyContent::Center,<br>        align_items: AlignItems::Center,<br>        ..default()<br>    };<br>    //Draw the grid layout!<br>    commands<br>        .spawn(NodeBundle {<br>            style: Style {<br>                //Create a grid layout,<br>                display: Display::Grid,<br>                width: Val::Percent(100.0),<br>                height: Val::Percent(100.0),<br>                grid_template_columns: vec![<br>                    GridTrack::auto()<br>                ],<br>                //Top Row will take up all the space after the bottom row is complete.<br>                grid_template_rows: vec![<br>                    GridTrack::flex(1.0), GridTrack::px(STATUS_BAR_PX)<br>                ],<br>                ..default()<br>            },<br>            background_color: BackgroundColor(Color::WHITE),<br>            ..default()<br>        })<br>        .with_children(|builder| {<br>            //Game Area<br>            builder.spawn(NodeBundle {<br>                style: Style {<br>                    //Create a grid layout,<br>                    display: Display::Grid,<br>                    width: Val::Percent(100.0),<br>                    height: Val::Percent(100.0),<br>                    grid_template_columns: vec![<br>                        GridTrack::auto(); usize::from(board.squares_wide)<br>                    ],<br>                    grid_template_rows: vec![<br>                        GridTrack::auto(); usize::from(board.squares_high)<br>                    ],<br>                    ..default()<br>                },<br>                background_color: BackgroundColor(Color::WHITE),<br>                ..default()<br>            })<br>            .with_children(|game_area_builder| {<br>                //Every other will be black or white!<br>                for c in 0..board.squares_wide {<br>                    for r in 0..board.squares_high {<br>                        //Set the color based on the board state.<br>                        let color = if board.squares[usize::from(c)][usize::from(r)] {<br>                            Color::BLACK<br>                        } else {<br>                            Color::WHITE<br>                        };<br>                        let grid_loc = GridLocation {column: c, row: r};<br>                        game_area_builder.spawn(<br>                            (ButtonBundle {<br>                                style: button_style.clone(),<br>                                background_color: BackgroundColor(color),<br>                                ..default()<br>                            }, grid_loc)<br>                        );<br>                    }<br>                }<br>            });<br>            //Status Tray<br>            builder.spawn(NodeBundle {<br>                style: Style {<br>                    display: Display::Grid,<br>                    padding: UiRect::all(Val::Px(6.0)),<br>                    grid_template_rows: vec![<br>                        GridTrack::auto()<br>                    ],<br>                    //Left slot, right slot.<br>                    grid_template_columns: vec![<br>                        GridTrack::auto(), GridTrack::auto()<br>                    ],<br>                    ..default()<br>                },<br>                ..default()<br>            })<br>            .with_children(|tray_builder| {<br>                tray_builder.spawn((TextBundle::from_section(<br>                    &quot;Running: [space] to pause, [c] to clear.&quot;,<br>                    TextStyle {<br>                        font: Handle::default(),<br>                        font_size: 20.0,<br>                        color: Color::BLACK,<br>                    },<br>                ), GameStateText));<br>                tray_builder.spawn((TextBundle::from_section(<br>                    format!(&quot;Iter:{}; Alive:{}&quot;, metadata.iterations, board.alive_squares),<br>                    TextStyle {<br>                        font: Handle::default(),<br>                        font_size: 20.0,<br>                        color: Color::BLACK,<br>                    },<br>                ).with_text_alignment(TextAlignment::Right), IterationText));<br>            });<br>        });<br>}<br><br>fn game_tick_timer(mut game_board_update_needed: EventWriter&lt;BoardNeedsUpdateEvent&gt;) {<br>    game_board_update_needed.send_default();<br>}<br><br>#[allow(clippy::type_complexity)]<br>fn button_system(mut interaction_query: Query&lt;<br>    (<br>        &amp;Interaction,<br>        &amp;GridLocation,<br>    ),<br>    (Changed&lt;Interaction&gt;, With&lt;Button&gt;),<br>&gt;, mut board: ResMut&lt;Board&gt;, mut board_needs_drawing: EventWriter&lt;BoardNeedsDrawingEvent&gt;,<br>    mut status_bar_needs_update: EventWriter&lt;StatusBarNeedsDrawingEvent&gt;) {<br>    for (interaction, grid_loc) in &amp;mut interaction_query {<br>        match *interaction {<br>            Interaction::Pressed =&gt; {<br>                let r = usize::from(grid_loc.row);<br>                let c = usize::from(grid_loc.column);<br>                //Get the game state.<br>                let cur = board.squares[c][r];<br>                if cur {<br>                    board.alive_squares -= 1;<br>                } else {<br>                    board.alive_squares += 1;<br>                }<br>                println!(&quot;Button pressed at ({c},{r}) -- Currently:{cur}&quot;);<br>                board.squares[c][r] = !cur;<br>                board_needs_drawing.send_default();<br>                status_bar_needs_update.send_default();<br>            },<br>            Interaction::Hovered | Interaction::None =&gt; {},<br>        }<br>    }<br>}<br><br>#[allow(clippy::needless_pass_by_value)]<br>fn keyboard_system(keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;, game_state: Res&lt;State&lt;GameState&gt;&gt;, mut next_game_state: ResMut&lt;NextState&lt;GameState&gt;&gt;, <br>    mut board: ResMut&lt;Board&gt;, mut board_needs_drawing_events: EventWriter&lt;BoardNeedsDrawingEvent&gt;,<br>    mut board_update_events: EventWriter&lt;BoardNeedsUpdateEvent&gt;, mut status_bar_needs_redraw: EventWriter&lt;StatusBarNeedsDrawingEvent&gt;) {<br>    if keyboard_input.just_pressed(KeyCode::Space) {<br>        match game_state.to_owned() {<br>            GameState::Running =&gt; {<br>                println!(&quot;Pausing&quot;);<br>                next_game_state.set(GameState::Paused);<br>            },<br>            GameState::Paused =&gt; {<br>                println!(&quot;Running&quot;);<br>                next_game_state.set(GameState::Running);<br>            },<br>        }<br>        status_bar_needs_redraw.send_default();<br>    }<br>    if keyboard_input.just_pressed(KeyCode::C) {<br>        println!(&quot;Clear&quot;);<br>        for c in 0..usize::from(board.squares_wide) {<br>            for r in 0..usize::from(board.squares_high) {<br>                board.squares[c][r] = false;<br>            }<br>        }<br>        board.alive_squares = 0;<br>        board_needs_drawing_events.send_default();<br>        status_bar_needs_redraw.send_default();<br>    }<br>    if keyboard_input.just_pressed(KeyCode::N) {<br>        println!(&quot;Next&quot;);<br>        //Send an update to update the board state, including the iterations.<br>        if game_state.to_owned() == GameState::Paused {<br>            board_update_events.send_default();<br>        } else {<br>            println!(&quot;Next disabled when not paused.&quot;);<br>        } <br>    }<br>}<br><br>#[allow(clippy::type_complexity, clippy::needless_pass_by_value)]<br>fn status_bar_text_update(mut text_params: ParamSet&lt;(Query&lt;&amp;mut Text, With&lt;GameStateText&gt;&gt;, Query&lt;&amp;mut Text, With&lt;IterationText&gt;&gt;)&gt;, board: Res&lt;Board&gt;,<br>    metadata: Res&lt;GameMetadata&gt;, next_game_state: Res&lt;NextState&lt;GameState&gt;&gt;, mut status_bar_needs_redraw: EventReader&lt;StatusBarNeedsDrawingEvent&gt;) {<br>    if status_bar_needs_redraw.is_empty() {<br>        return;<br>    }<br>    status_bar_needs_redraw.clear();<br>    <br>    let game_state = next_game_state.0.as_ref().unwrap_or(&amp;GameState::Running);<br>    let mut game_state_query = text_params.p0();<br>    match game_state {<br>        GameState::Running =&gt; {<br>            game_state_query.single_mut().sections[0].value = &quot;Running: [space] to pause, [c] to clear.&quot;.to_string();<br>        },<br>        GameState::Paused =&gt; {<br>            game_state_query.single_mut().sections[0].value = &quot;Paused: [space] to resume, [c] to clear, [n] for next.&quot;.to_string();<br>        },<br>    }<br>    let mut iter_state_query = text_params.p1();<br>    let new_text = format!(&quot;Iter:{}; Alive:{}&quot;, metadata.iterations, board.alive_squares);<br>    iter_state_query.single_mut().sections[0].value = new_text;<br>}<br><br><br><br>fn update_board(mut query: Query&lt;&amp;GridLocation&gt;, mut board: ResMut&lt;Board&gt;, mut metadata: ResMut&lt;GameMetadata&gt;,<br>    mut board_update_events: EventReader&lt;BoardNeedsUpdateEvent&gt;, mut board_needs_draw_event: EventWriter&lt;BoardNeedsDrawingEvent&gt;,<br>    mut status_bar_needs_update: EventWriter&lt;StatusBarNeedsDrawingEvent&gt;) {<br>    //Fetch the neighbor counts.<br>    if board_update_events.is_empty() {<br>        return;<br>    }<br>    board_update_events.clear();<br>    let neighbor_counts = get_alive_neighbor_counts(board.as_ref());<br>    let mut alive_count = 0;<br>    for grid_loc in &amp;mut query {<br>        let c = usize::from(grid_loc.column);<br>        let r = usize::from(grid_loc.row);<br>        let cur = board.squares[c][r];<br>        let n = neighbor_counts[c][r];<br>        let mut new_state = cur;<br>        if cur {<br>            // Live cell<br>            //fewer than two live neighbours dies, as if by underpopulation.<br>            if n &lt; 2 {<br>                //Underpop<br>                new_state = false;<br>            }<br>            //two or three live neighbours lives on to the next generation.<br>            if n == 2 || n == 3 {<br>                //We live!<br>                new_state = true;<br>            }<br>            //more than three live neighbours dies, as if by overpopulation.<br>            if n &gt; 3 {<br>                //Overpop<br>                new_state = false;<br>            }<br>        } else {<br>            // Dead Cell<br>            //exactly three live neighbours becomes a live cell, as if by reproduction.<br>            if n == 3 {<br>                //breeeed<br>                new_state = true;<br>            }<br>        }<br>        if new_state {<br>            alive_count += 1;<br>        }<br>        //Update the data<br>        board.squares[c][r] = new_state;<br>    }<br>    board.alive_squares = alive_count;<br>    metadata.iterations += 1;<br>    board_needs_draw_event.send_default();<br>    status_bar_needs_update.send_default();<br>}<br><br>#[allow(clippy::needless_pass_by_value)]<br>fn draw_board(mut query: Query&lt;(&amp;mut BackgroundColor, &amp;GridLocation)&gt;, board: Res&lt;Board&gt;, mut board_needs_draw_events: EventReader&lt;BoardNeedsDrawingEvent&gt;) {<br>    if board_needs_draw_events.is_empty() {<br>        return;<br>    }<br>    board_needs_draw_events.clear();<br>    for (mut color, grid_loc) in &amp;mut query {<br>        let alive = board.squares[usize::from(grid_loc.column)][usize::from(grid_loc.row)];<br>        if alive {<br>            *color = Color::BLACK.into();<br>        } else {<br>            *color = Color::WHITE.into();<br>        }<br>    }<br>}<br><br>fn get_alive_neighbor_counts(board: &amp;Board) -&gt; Vec&lt;Vec&lt;usize&gt;&gt; {<br>    let height = usize::from(board.squares_high);<br>    let width = usize::from(board.squares_wide);<br>    let mut neighbor_counts = vec![vec![0; height]; width];<br>    for (c, row) in neighbor_counts.iter_mut().enumerate() {<br>        for (r, item) in  row.iter_mut().enumerate() {<br>            let mut neighbors = 0;<br>            //Top<br>            if r &gt; 0 {<br>                //T/L<br>                if c &gt; 0 &amp;&amp; board.squares[c-1][r-1] {<br>                    neighbors += 1;<br>                }<br>                //T/C<br>                if board.squares[c][r-1] {<br>                    neighbors += 1;<br>                }<br>                //T/R<br>                if c+1 &lt; width &amp;&amp; board.squares[c+1][r-1] {<br>                    neighbors += 1;<br>                }<br>            }<br>            //Left<br>            if c &gt; 0 &amp;&amp; board.squares[c-1][r] {<br>                neighbors += 1;<br>            }<br>            //Right<br>            if c+1 &lt; width &amp;&amp; board.squares[c+1][r] {<br>                neighbors += 1;<br>            }<br>            //Bottom<br>            if r+1 &lt; height {<br>                //B/L<br>                if c &gt; 0 &amp;&amp; board.squares[c-1][r+1] {<br>                    neighbors += 1;<br>                }<br>                //B/C<br>                if board.squares[c][r+1] {<br>                    neighbors += 1;<br>                }<br>                //B/R<br>                if c+1 &lt; width &amp;&amp; board.squares[c+1][r+1] {<br>                    neighbors += 1;<br>                }<br>            }<br>            *item = neighbors;<br>        }<br>    }<br>    neighbor_counts<br>}</pre><p>Last reminder‚Ää‚Äî‚Ääcommit it for good¬†measure!</p><p>git commit -a -m ‚ÄúMake board 100x100 and optimize dependencies.‚Äù</p><h3>Wrap it¬†up!</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/400/1*FhrjoJmcVIV7w4Spn6vA_w.gif" /></figure><p>That wraps up our Bevy game of life tutorial! Thank you for reading, and I hope you had fun running through it with me! Please feel free to reach out if there are any areas that need to be clarified or corrected.</p><p>For additional fun there are a few things I didn‚Äôt add to the game that would be nice features.</p><ul><li>Add the ability to go back in history up to N iterations via a ‚Äòprevious‚Äô keypress.</li><li>Game menu with configurable items like board size, game speed, game color scheme,¬†etc.</li><li>The ability to resize the game‚Äôs window up and down including automatic tile¬†scaling.</li><li>Add ability to ‚Äòload‚Äô a csv of various board states to try out different scenarios.</li><li>Add a ‚Äòclear and randomize‚Äô option as a keypress that restarts the sim with the squares in a random on/off configuration.</li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c7f7e5322640" width="1" height="1" alt="">

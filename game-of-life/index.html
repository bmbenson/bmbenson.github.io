---
layout: post
title: Rust — Conway’s Game of Life in Bevy ECS
tag:
- rustlang
- coding
- games
- bevy
---

<h3>Rust — Conway’s Game of Life in Bevy ECS</h3><h3>Introduction</h3><p>Hey all, this is my first tutorial and medium post. I decided to share a tutorial based on some recent things I learned when working with the Bevy game engine for the Rust programming language.</p><p>For this article I wanted to focus on how we might recreate one of the oldest computer games/simulations out there, called <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Conway’s Game of Life</a> created in 1969 by John Conway. The simulation is quite basic in that there are only four rules, but create some very interesting patterns, some only showing up/stabilizing after hundreds or thousands of iterations.</p><h3>Prerequisites</h3><p>This tutorial assumes some familiarity with Rust and a working installation of git. If you aren’t read up, no worries! I have linked some resources to fill in your gaps.</p><ul><li>Installing Rust: <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a></li><li>Installing Git: <a href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git">https://git-scm.com/book/en/v2/Getting-Started-Installing-Git</a></li><li>Using Git: <a href="https://www.codecademy.com/learn/learn-git">https://www.codecademy.com/learn/learn-git</a></li></ul><p>For a Rust editor, I like VSCode these days: <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a> — we don’t cover anything VSCode specific in this tutorial, so use whatever editor suits you.</p><p>Ensure you are on the latest version of cargo and rust — to do so, execute rustup update to update your tools.</p><p>Throughout the tutorial I will be including the full main.rs file to resync. If you want to skip ahead, each section generally has a commit message you can find in <a href="https://github.com/bmbenson/bevy-game-of-life">my github repo</a> and using git you can follow along with much less typing + copy/paste.</p><h3>Getting Started — Display something</h3><p>In your Rust project workspace initialize the cargo and git workspace:</p><pre>cargo new game-of-life<br>cd game-of-life<br>git init<br>git add .<br>git commit -m &quot;Initial commit of a new cargo binary workspace.&quot;</pre><p><strong>Note: </strong>While we’re not covering git in this tutorial, I will be injecting reminders to commit the progress from time to time.</p><p>Add bevy to your cargo dependencies cargo add bevy</p><p>The cargo add command automatically added the new bevy dependency to your Cargo.toml file. Open up the file to see.</p><p>Cargo.toml should look like:</p><pre>[package]<br>name = &quot;game-of-life&quot;<br>version = &quot;0.1.0&quot;<br>edition = &quot;2021&quot;<br><br># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html<br><br>[dependencies]<br>bevy = &quot;0.12.1&quot;</pre><p><em>Note: </em>As of the writing of this article, the latest bevy is 0.12.1 — If in the future there is an update that causes this tutorial to be incompatible, please reach out and I will work on making an update!</p><p>In your src/main.rs file, we’ll add the basic bevy app and run it to be sure the dependencies and the cargo workspace are set up properly. Throughout the code blocks I have included #![warn(clippy::pedantic)] which causes the linter to highlight areas of code that do not meet (stringent) best practices, but in some areas the linter suggestions conflict with the methods Bevy uses for passing params into the systems, so you’ll see we disable a few clippy checks where necessary.</p><pre>//main.rs<br>#![warn(clippy::pedantic)]<br><br>use bevy::prelude::*;<br><br>fn main() {<br>    println!(&quot;Bevy app starting!&quot;);<br>    App::new().run();<br>    println!(&quot;Bevy app complete!&quot;);<br>}</pre><p>When you execute cargo run You should see both println! lines in the console, but a bevy window does not yet show up to display anything. Let&#39;s correct that!</p><p>To show a window, we will need to use a Bevy Plugin, — Bevy splits separate parts of the app into plugins. To make a window display, we can get off the ground by adding a set of plugins as a group — one called DefaultPlugins</p><pre>//main.rs<br>#![warn(clippy::pedantic)]<br>use bevy::prelude::*;<br><br>fn main() {<br>    println!(&quot;Bevy app starting!&quot;);<br>    App::new()<br>        .add_plugins(DefaultPlugins)<br>        .run();<br>}</pre><p>Now, when we execute cargo run we will see a blank window.</p><p>Let’s add a title to the window — instead of using only the default plugins with their default settings, we want to modify the WindowPlugin to have a title and specific resolution displayed.</p><pre>//main.rs<br>#![warn(clippy::pedantic)]<br><br>use bevy::prelude::*;<br><br>// Window starting dimensions<br>const WINDOW_START_HEIGHT: f32 = 800.0;<br>const WINDOW_START_WIDTH: f32 = 700.0;<br>fn main() {<br>    println!(&quot;Game of life app starting!&quot;);<br>    App::new()<br>        .add_plugins(<br>            DefaultPlugins.set(WindowPlugin {<br>                primary_window: Some(Window {<br>                    title: &quot;Conway&#39;s Game of Life&quot;.into(),<br>                    resolution: (WINDOW_START_WIDTH, WINDOW_START_HEIGHT).into(),<br>                    ..default()<br>                }),<br>                ..default()<br>            })<br>        )<br>        .run();<br>}</pre><p>For this we still use the majority of the DefaultPlugins, but we override the WindowPlugin with our custom settings &amp; leave all others default. Note: The ..default() is the part that fills in the remaining elements of the struct for us with the defaults, which for Bevy are quite sane.</p><p>Execute: cargo run</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/700/1*aOaXgG7NtgGXfAss9ny34A.png" /></figure><p>NICE, we have something displayed &amp; our window is titled — let’s commit for good measure!</p><pre>git commit -a -m &quot;Window title and display functionality.&quot;</pre><h3>Adding the game board</h3><p>Now that we have something displayed, let’s get a game board going.</p><pre>//main.rs<br>#![warn(clippy::pedantic)]<br><br>use bevy::prelude::*;<br><br>//Default for the tile sizes.<br>const TILE_SIZE: u16 = 40;<br><br>struct Board {<br>    squares_wide: u16,<br>    squares_high: u16,<br>}<br><br>fn main() {<br>    println!(&quot;Bevy app starting!&quot;);<br>    let cols = 20;<br>    let rows = 20;<br>    let board = Board {squares_wide: cols, squares_high: rows};<br>    let window_width = TILE_SIZE * board.squares_wide;<br>    let window_height =  TILE_SIZE * board.squares_high;<br>    App::new()<br>        .add_plugins(<br>            DefaultPlugins.set(WindowPlugin {<br>                primary_window: Some(Window {<br>                    title: &quot;Conway&#39;s Game of Life&quot;.into(),<br>                    resolution: (f32::from(window_width), f32::from(window_height)).into(),<br>                    ..default()<br>                }),<br>                ..default()<br>            })<br>        )<br>        .run();<br>}</pre><p>The window displays similar to before, but the implementation is a bit more flexible with a custom board size, so we can change it easily in the future if we want a tiny or massive board (though we’ll likely want to decouple from a fixed pixel count per square if we get too large).</p><p>To actually display something inside the window we need what Bevy calls a camera. In this case for our Game Of Life, we will be using a 2d camera. Bevy is an Entity Container System style engine, and for adding the camera we’ll add it as a system. See <a href="https://bevyengine.org/learn/book/getting-started/ecs/">here</a> for more background and details on the benefits of ECS. The major thing it brings is the ability to separate out the data representations we need for our game from the functions (systems) that use them.</p><p>To add the camera, we will need to create an initialization function that adds the one-time elements to our app, which will be the 2d camera and a background — We do this by calling .add_systems(Startup, initial_setup) during our app build.</p><pre>//main.rs<br>#![warn(clippy::pedantic)]<br><br>use bevy::prelude::*;<br><br>//Default for the tile sizes.<br>const TILE_SIZE: u16 = 40;<br><br>struct Board {<br>    squares_wide: u16,<br>    squares_high: u16,<br>}<br><br>fn main() {<br>    println!(&quot;Bevy app starting!&quot;);<br>    let cols = 20;<br>    let rows = 20;<br>    let board = Board {squares_wide: cols, squares_high: rows};<br>    let window_width = TILE_SIZE * board.squares_wide;<br>    let window_height =  TILE_SIZE * board.squares_high;<br>    App::new()<br>        .add_plugins(<br>            DefaultPlugins.set(WindowPlugin {<br>                primary_window: Some(Window {<br>                    title: &quot;Conway&#39;s Game of Life&quot;.into(),<br>                    resolution: (f32::from(window_width), f32::from(window_height)).into(),<br>                    ..default()<br>                }),<br>                ..default()<br>            })<br>        )<br>        .add_systems(Startup, initial_setup)<br>        .run();<br>}<br><br>fn initial_setup(mut commands: Commands) {<br>    commands.spawn(Camera2dBundle::default());<br>}</pre><p>The spawn to the command will enqueue a Camera2dBundle to be added to the scene.</p><p>We also need something for the camera to display, so let’s start with something simple — A beautiful blue background.</p><pre>//main.rs intialize_setup function    <br>//Add after the 2d Camera Spawn.<br>    //Draw the background!<br>    commands.spawn(NodeBundle {<br>        style: Style {<br>            width: Val::Percent(100.0),<br>            height: Val::Percent(100.0),<br>            position_type: PositionType::Absolute,<br>            justify_content: JustifyContent::SpaceAround,<br>            align_items: AlignItems::Center,<br>            ..default()<br>        },<br>        background_color: Color::BLUE.into(),<br>        ..default()<br>    });</pre><p>For this we’re enqueuing a spawn of a <a href="https://docs.rs/bevy/latest/bevy/prelude/struct.NodeBundle.html">NodeBundle</a> to also be added to the scene. We tell it where to place the element as well as how large it should be in relation to the parent element. If we were to change the Val::Percent to other values, we will see the BG area shrink.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*kWdCIYfDZ2W_abcRZPSEvQ.png" /></figure><p>Execute: cargo run</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*92p57fy-hs96-nHTcSvKUg.png" /></figure><p>That’s… a lot of blue.</p><pre>git commit -a -m &quot;Add camera and background on startup.&quot;</pre><p>Okay, great, we now have a background! Let’s actually draw some board elements.</p><p>For this, we will use bevy’s built in grid system… to know how many rows and columns we’ll need to add access to the board struct. Let’s add it to the method signature of initial_setup .</p><pre>fn initial_setup(mut commands: Commands, board: Res&lt;Board&gt;) {</pre><p>however… due to Bevy trait constraints this won’t compile as Board needs the Resource trait, so we will add a derive Resource trait to the Board.</p><pre>#[derive(Resource)]<br>struct Board {<br>    squares_wide: u16,<br>    squares_high: u16,<br>}</pre><p><em>Side note: </em>A resource in Bevy isn’t one of the letters in ECS, but is instead something that’s “globally unique” for the game and can be pulled into any system we need to read or modify the state in. We’ll later add a few more resources and elements to the Board which will be useful in many different systems.</p><p>In addition to changing the method signature and traits of the board, we need to add the board resource to be available for Bevy to pull in. For that we need to add the Board resource to our app in the main function. Only one resource of each type can be added to the app/world at a time, so if we constructed a second board and inserted it, bevy would panic.</p><pre>//main.rs main function<br>//Add this line before the add_systems(Startup, initial_setup) call.<br>    .insert_resource(board)</pre><p>Okay, now we move on to changing our background NodeBundle to be a grid layout. Replace our BEAUTIFUL blue background spawn with one that’s a grid type. Then after the grid is spawned, we will add some child nodes to it.</p><p>For this we iterate over the columns and and rows to add each of the squares, alternating the color of the grid node between red and black.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*7wTfDXACKDmEemszcpMpSQ.png" /></figure><pre>//main.rs intialize_setup function<br>//Replace the spawn NodeBundle block<br>    commands<br>        .spawn(NodeBundle {<br>            style: Style {<br>                // Create a grid layout, at 100% of the parent element<br>                // Height and width.<br>                display: Display::Grid,<br>                width: Val::Percent(100.0),<br>                height: Val::Percent(100.0),<br>                grid_template_columns: vec![<br>                    GridTrack::auto(); usize::from(board.squares_wide)<br>                ],<br>                grid_template_rows: vec![<br>                    GridTrack::auto(); usize::from(board.squares_high)<br>                ],<br>                ..default()<br>            },<br>            background_color: BackgroundColor(Color::WHITE),<br>            ..default()<br>        })<br>        .with_children(|builder| {<br>            //Every other will be black or red!<br>            for c in 0..board.squares_wide {<br>                for r in 0..board.squares_high {<br>                    let color = if (r + c) % 2 == 0 {<br>                        Color::RED<br>                    } else {<br>                        Color::BLACK<br>                    };<br>                    builder.spawn(NodeBundle {<br>                        style: Style {<br>                            display: Display::Grid,<br>                            ..default()<br>                        },<br>                        background_color: BackgroundColor(color),<br>                        ..default()<br>                    });<br>                }<br>            }<br>        });</pre><p>Okay, in case anything was lost, here’s a full main.rs</p><pre>//main.rs<br>#![warn(clippy::pedantic)]<br><br>use bevy::prelude::*;<br><br>//Default for the tile sizes.<br>const TILE_SIZE: u16 = 40;<br><br>#[derive(Resource)]<br>struct Board {<br>    squares_wide: u16,<br>    squares_high: u16,<br>}<br><br>fn main() {<br>    println!(&quot;Bevy app starting!&quot;);<br>    let cols = 20;<br>    let rows = 20;<br>    let board = Board {squares_wide: cols, squares_high: rows};<br>    let window_width = TILE_SIZE * board.squares_wide;<br>    let window_height =  TILE_SIZE * board.squares_high;<br>    App::new()<br>        .add_plugins(<br>            DefaultPlugins.set(WindowPlugin {<br>                primary_window: Some(Window {<br>                    title: &quot;Conway&#39;s Game of Life&quot;.into(),<br>                    resolution: (f32::from(window_width), f32::from(window_height)).into(),<br>                    ..default()<br>                }),<br>                ..default()<br>            })<br>        )<br>        .insert_resource(board)<br>        .add_systems(Startup, initial_setup)<br>        .run();<br>}<br><br>fn initial_setup(mut commands: Commands, board: Res&lt;Board&gt;) {<br>    commands.spawn(Camera2dBundle::default());<br>    //Draw the grid layout!<br>    commands<br>        .spawn(NodeBundle {<br>            style: Style {<br>                // Create a grid layout, at 100% of the parent element<br>                // Height and width.<br>                display: Display::Grid,<br>                width: Val::Percent(100.0),<br>                height: Val::Percent(100.0),<br>                grid_template_columns: vec![<br>                    GridTrack::auto(); usize::from(board.squares_wide)<br>                ],<br>                grid_template_rows: vec![<br>                    GridTrack::auto(); usize::from(board.squares_high)<br>                ],<br>                ..default()<br>            },<br>            background_color: BackgroundColor(Color::WHITE),<br>            ..default()<br>        })<br>        .with_children(|builder| {<br>            //Every other will be black or red!<br>            for c in 0..board.squares_wide {<br>                for r in 0..board.squares_high {<br>                    let color = if (r + c) % 2 == 0 {<br>                        Color::RED<br>                    } else {<br>                        Color::BLACK<br>                    };<br>                    builder.spawn(NodeBundle {<br>                        style: Style {<br>                            display: Display::Grid,<br>                            ..default()<br>                        },<br>                        background_color: BackgroundColor(color),<br>                        ..default()<br>                    });<br>                }<br>            }<br>        });<br>}</pre><p>Now let’s see what we have by executing: cargo run</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*45yvqLScPUOVA1YXz6KAmA.png" /></figure><p>Sweet! Looks like we can play a huge game of checkers on that board!</p><p>Let’s commit it to be able to return here as we’re about to change a good amount of stuff! git commit -a -m &quot;Checker board view.&quot;</p><h3>Consistent Game State</h3><p>The every other red + black was nice to demonstrate how to draw, but eventually we’ll need to change the colors of the squares based on their alive/dead status, so let’s store the board state in our Board Struct. For this we’ll add a 2d vector to the Board object:</p><pre>//main.rs<br>#[derive(Resource)]<br>struct Board {<br>    squares_wide: u16,<br>    squares_high: u16,<br>    squares: Vec&lt;Vec&lt;bool&gt;&gt;,<br>}</pre><p>And we’ll initialize it and pass it into the board constructor.</p><pre>//main.rs main function<br>// After the first println!<br>    let cols = 20;<br>    let rows = 20;<br>    // Create a 2d vector where every other square is on or off.<br>    // This is equivalent to a nested for loop over cols then row elements.<br>    let board_state = (0..cols).map(|col| <br>            (0..rows).map(|row| <br>                (col + row) % 2 == 0)<br>                .collect())<br>        .collect();<br><br>    let board = Board {squares_wide: cols, squares_high: rows, squares: board_state};<br>    let window_width = TILE_SIZE * board.squares_wide;<br>    let window_height =  TILE_SIZE * board.squares_high;<br><br>//main.rs intialize_setup function<br>// within the with_children block, make it use the squares boolean.<br>            for c in 0..board.squares_wide {<br>                for r in 0..board.squares_high {<br>                    let color = if board.squares[usize::from(c)][usize::from(r)] {<br>                        Color::RED<br>                    } else {<br>                        Color::BLACK<br>                    };</pre><p>Ok, so we added a two dimensional array (vector of vectors) that contain a boolean of the state of the square of alive or dead — We then use that state for knowing what color of square we should spawn.</p><p>This allows us to know what state each square is in without needing some deep knowledge of how the colors are rendered.</p><p>Let’s commit!</p><p>git commit -a -m &quot;Board now controls alive/dead color.&quot;</p><h3>User Mouse Input</h3><p>Many game engines have complex click handling logic, but fortunately Bevy solves most of this for us — Instead of using a NodeBundle for each RED/BLACK square, we can use a ButtonBundle instead. The way we interact with it is very similar to NodeBundle, but it also has built in support for button presses and mouse hovers. First we’ll migrate to ButtonBundles. We’re also going to use a White/Black color scheme to be more traditional w/ the Game of Life. Feel free to use whatever color scheme you’d like. Black will represent an alive square, and white will represent a dead one.</p><pre>//main.rs<br>//In initial_setup - Replace the child NodeBundle with one for a ButtonBundle.<br>#[allow(clippy::needless_pass_by_value)]<br>fn initial_setup(mut commands: Commands, board: Res&lt;Board&gt;) {<br>    commands.spawn(Camera2dBundle::default());<br>    //Button style<br>    let button_style = Style {<br>        display: Display::Grid,<br>        justify_content: JustifyContent::Center,<br>        align_items: AlignItems::Center,<br>        ..default()<br>    };<br>    //Draw the grid layout!<br>    commands<br>        .spawn(NodeBundle {<br>            style: Style {<br>                // Create a grid layout, at 100% of the parent element<br>                // Height and width.<br>                display: Display::Grid,<br>                width: Val::Percent(100.0),<br>                height: Val::Percent(100.0),<br>                grid_template_columns: vec![<br>                    GridTrack::auto(); usize::from(board.squares_wide)<br>                ],<br>                grid_template_rows: vec![<br>                    GridTrack::auto(); usize::from(board.squares_high)<br>                ],<br>                ..default()<br>            },<br>            background_color: BackgroundColor(Color::WHITE),<br>            ..default()<br>        })<br>        .with_children(|builder| {<br>            //Every other will be black or white!<br>            for c in 0..board.squares_wide {<br>                for r in 0..board.squares_high {<br>                    let color = if board.squares[usize::from(c)][usize::from(r)] {<br>                        Color::BLACK<br>                    } else {<br>                        Color::WHITE<br>                    };<br>                    builder.spawn(ButtonBundle {<br>                        style: button_style.clone(),<br>                        background_color: BackgroundColor(color),<br>                        ..default()<br>                    });<br>                }<br>            }<br>        });<br>}</pre><p>And to handle the mouse clicks (button presses), we’ll need a new system. This system will be executed on each Update event. The update schedule is different from what we’ll use later for game movement, but it’s the best for showing rapid updates for our game-users.</p><pre>//main.rs main - Add another system to the app after the initial_setup addition.<br>        .add_systems(Update, button_system)<br>//Add to the bottom of the file.<br>#[allow(clippy::type_complexity)]<br>fn button_system(mut interaction_query: Query&lt;<br>    (<br>        &amp;Interaction,<br>        &amp;mut BackgroundColor,<br>    ),<br>    (Changed&lt;Interaction&gt;, With&lt;Button&gt;),<br>&gt;) {<br>    for (interaction, mut color) in &amp;mut interaction_query {<br>        match *interaction {<br>            Interaction::Pressed =&gt; {<br>                println!(&quot;Button pressed!&quot;);<br>                *color = if color.0.eq(&amp;Color::BLACK) {<br>                    Color::WHITE<br>                }<br>                else {<br>                    Color::BLACK<br>                }.into();<br>            },<br>            Interaction::Hovered | Interaction::None =&gt; {},<br>        }<br>    }<br>}</pre><p>Now, run the app — you can now toggle different squares on and off! Make your own pattern for fun.</p><p>Congratulations, we just made an incredibly boring version of MSPaint! 🥳🎉🎉🥳</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*kKltZfCk__NvDAPZ1yy67Q.png" /></figure><p>git commit -a -m &quot;Minimal working square toggle with the mouse.&quot;</p><p>Keen observers will start to notice a bit of code smell rising up — We have the Board struct that is supposed to contain the state of the squares, but those true/false combinations no longer match our world when a button is toggled. To do this, we’ll need to change our trusty 2d vector values as well. The reason for the separate game-state array (from the UX elements) might be unclear now, but we’ll round that out in due time. We should strive for one Source of Truth™️ for our states, and here we have strayed from that. Let’s correct it!</p><p>At first glance it seems the best place to add it is in that button handler — While that is true, we will need some additional information for that, as when the button is clicked it doesn’t actually “know” where it is in the grid to then map it to the 2d vector coordinates. The good news is we can add the coords to the bundles when we spawn them so when it is clicked we have that information.</p><p>Let’s create a new GridLocation Component struct.</p><pre>//main.rs<br>//below the board struct.<br>#[derive(Component, Debug)]<br>struct GridLocation {<br>    row: u16,<br>    column: u16<br>}</pre><p>And in initial_setupafter our color setting we spawn the ButtonBundle and the GridLocation in a tuple.</p><pre>//main.rs initial_setup<br>//Instead of using the builder to spawn a ButtonBundle, we do it as a tuple with a GridLocation.<br>//After the color determination, replace the existing spawn.<br>                    let grid_loc = GridLocation {column: c, row: r};<br>                    builder.spawn(<br>                        (ButtonBundle {<br>                            style: button_style.clone(),<br>                            background_color: BackgroundColor(color),<br>                            ..default()<br>                        }, grid_loc)<br>                    );</pre><p>This lets us change our button system query to include the grid location. We also need to add a mutable reference to the board as we’re planning to modify the board on a button click.</p><pre>//main.rs<br>#[allow(clippy::type_complexity)]<br>fn button_system(mut interaction_query: Query&lt;<br>        (<br>            &amp;Interaction,<br>            &amp;mut BackgroundColor,<br>            &amp;GridLocation<br>        ),<br>        (Changed&lt;Interaction&gt;, With&lt;Button&gt;),<br>    &gt;, mut board: ResMut&lt;Board&gt;) {<br>    for (interaction, mut color, grid_loc) in &amp;mut interaction_query {<br>        match *interaction {<br>            Interaction::Pressed =&gt; {<br>                let r = usize::from(grid_loc.row);<br>                let c = usize::from(grid_loc.column);<br>                //Get the game state.<br>                let cur = board.squares[c][r];<br>                println!(&quot;Button pressed at ({c},{r}) -- Currently:{cur}&quot;);<br><br>                if cur { //Alive to dead<br>                    *color = Color::WHITE.into();<br>                }<br>                else {<br>                    *color = Color::BLACK.into();<br>                }<br>                board.squares[c][r] = !cur;<br>            },<br>            Interaction::Hovered | Interaction::None =&gt; {},<br>        }<br>    }<br>}</pre><p>And with that… it looks like we have the same functionality!!! Wait… what?? Why did we do it then? The reason is to have one Source of Truth™️ for our game state — the UX elements could be a place to store this single source, but that mixes the the Game of Life rules with the UX methods we use to display things, which isn’t ideal.</p><p>For review, the full main.rs</p><pre>//main.rs<br>#![warn(clippy::pedantic)]<br><br>use bevy::prelude::*;<br><br>//Default for the tile sizes.<br>const TILE_SIZE: u16 = 40;<br><br>#[derive(Resource)]<br>struct Board {<br>    squares_wide: u16,<br>    squares_high: u16,<br>    squares: Vec&lt;Vec&lt;bool&gt;&gt;,<br>}<br><br>#[derive(Component, Debug)]<br>struct GridLocation {<br>    row: u16,<br>    column: u16<br>}<br><br>fn main() {<br>    println!(&quot;Bevy app starting!&quot;);<br>    let cols = 20;<br>    let rows = 20;<br>    // Create a 2d vector where every other square is on or off.<br>    // This is equivalent to a nested for loop over cols then row elements.<br>    let board_state = (0..cols).map(|col| <br>        (0..rows).map(|row| <br>            (col + row) % 2 == 0)<br>            .collect())<br>    .collect();<br>    let board = Board {squares_wide: cols, squares_high: rows, squares: board_state};<br>    let window_width = TILE_SIZE * board.squares_wide;<br>    let window_height =  TILE_SIZE * board.squares_high;<br>    App::new()<br>        .add_plugins(<br>            DefaultPlugins.set(WindowPlugin {<br>                primary_window: Some(Window {<br>                    title: &quot;Conway&#39;s Game of Life&quot;.into(),<br>                    resolution: (f32::from(window_width), f32::from(window_height)).into(),<br>                    ..default()<br>                }),<br>                ..default()<br>            })<br>        )<br>        .insert_resource(board)<br>        .add_systems(Startup, initial_setup)<br>        .add_systems(Update, button_system)<br>        .run();<br>}<br><br>fn initial_setup(mut commands: Commands, board: Res&lt;Board&gt;) {<br>    commands.spawn(Camera2dBundle::default());<br>    //Button style<br>    let button_style = Style {<br>        display: Display::Grid,<br>        justify_content: JustifyContent::Center,<br>        align_items: AlignItems::Center,<br>        ..default()<br>    };<br>    //Draw the grid layout!<br>    commands<br>        .spawn(NodeBundle {<br>            style: Style {<br>                // Create a grid layout, at 100% of the parent element<br>                // Height and width.<br>                display: Display::Grid,<br>                width: Val::Percent(100.0),<br>                height: Val::Percent(100.0),<br>                grid_template_columns: vec![<br>                    GridTrack::auto(); usize::from(board.squares_wide)<br>                ],<br>                grid_template_rows: vec![<br>                    GridTrack::auto(); usize::from(board.squares_high)<br>                ],<br>                ..default()<br>            },<br>            background_color: BackgroundColor(Color::WHITE),<br>            ..default()<br>        })<br>        .with_children(|builder| {<br>            //Every other will be black or white!<br>            for c in 0..board.squares_wide {<br>                for r in 0..board.squares_high {<br>                    let color = if board.squares[usize::from(c)][usize::from(r)] {<br>                        Color::BLACK<br>                    } else {<br>                        Color::WHITE<br>                    };<br>                    let grid_loc = GridLocation {column: c, row: r};<br>                    builder.spawn(<br>                        (ButtonBundle {<br>                            style: button_style.clone(),<br>                            background_color: BackgroundColor(color),<br>                            ..default()<br>                        }, grid_loc)<br>                    );<br>                }<br>            }<br>        });<br>}<br><br>#[allow(clippy::type_complexity)]<br>fn button_system(mut interaction_query: Query&lt;<br>    (<br>        &amp;Interaction,<br>        &amp;mut BackgroundColor,<br>        &amp;GridLocation<br>    ),<br>    (Changed&lt;Interaction&gt;, With&lt;Button&gt;),<br>&gt;, mut board: ResMut&lt;Board&gt;) {<br>    for (interaction, mut color, grid_loc) in &amp;mut interaction_query {<br>        match *interaction {<br>            Interaction::Pressed =&gt; {<br>                let r = usize::from(grid_loc.row);<br>                let c = usize::from(grid_loc.column);<br>                //Get the game state.<br>                let cur = board.squares[c][r];<br>                println!(&quot;Button pressed at ({c},{r}) -- Currently:{cur}&quot;);<br><br>                if cur { //Alive to dead<br>                    *color = Color::WHITE.into();<br>                }<br>                else {<br>                    *color = Color::BLACK.into();<br>                }<br>                board.squares[c][r] = !cur;<br>            },<br>            Interaction::Hovered | Interaction::None =&gt; {},<br>        }<br>    }<br>}</pre><p>git commit -a -m &quot;Use the game board array as the source of a square’s state.&quot;</p><h3>Add Game Movement</h3><p>Toggling buttons back and forth doesn’t exactly constitute a game, so let’s start adding some life to the board — First step on the journey is to toggle the square colors back and forth.</p><p>For that, we’ll add a new system which will be executed on a FixedUpdate (time) schedule, not on every Update event. If we were on each Update it would progress <em>far </em>too fast to keep track of.</p><pre>//main.rs<br><br>//below TILE_SIZE<br>const UPDATE_RATE_SEC: f64 = 0.5;<br>//main.rs in the main function<br>// To the app initialization<br>        .insert_resource(Time::&lt;Fixed&gt;::from_seconds(UPDATE_RATE_SEC))<br>        .add_systems(FixedUpdate, update_board)<br>        <br><br>//main.rs below button_system<br>//Update the board for every entity with both a backgroundcolor and a gridlocation.<br>fn update_board(mut query: Query&lt;(&amp;mut BackgroundColor, &amp;GridLocation)&gt;, mut board: ResMut&lt;Board&gt;) {<br>    for (mut color, grid_loc) in &amp;mut query {<br>        let c = usize::from(grid_loc.column);<br>        let r = usize::from(grid_loc.row);<br>        let cur = board.squares[c][r];<br>        // for now, toggle back and forth.<br>        if cur {<br>            *color = Color::WHITE.into();<br>        } else {<br>            *color = Color::BLACK.into();<br>        }<br>        board.squares[c][r] = !cur;<br>    }<br>}</pre><p>execute it with cargo run You should see the tile colors oscillate every half second -- Houston, we have … movement!</p><p>While we can still click to toggle things… it’s not exactly a game... but let’s commit anyways.</p><p>git commit -a -m &quot;Time based toggle of the squares back and forth.&quot;</p><p>For fun you can change the FixedUpdate to Update to see the crazy chaos that comes with updating WAY too fast!</p><h3>The Game of Life and Death</h3><p>Let’s add in the game of life rules.</p><p>For some background, Conway’s rules are:</p><pre>Any live cell with fewer than two live neighbours dies, as if by underpopulation.<br>Any live cell with two or three live neighbours lives on to the next generation.<br>Any live cell with more than three live neighbours dies, as if by overpopulation.<br>Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.</pre><p>To support easier evaluation, let’s create a function to calculate the number of neighbors.</p><p>This function checks our 8 (in bounds) neighbors to get an alive neighbor count. We calculate <em>all </em>neighbors <em>before </em>modifying the board object as if we do the check &amp; set while iterating through, we will inappropriately change the outcome of the yet to be evaluated cells.</p><pre>//main.rs below update_board<br>fn get_alive_neighbor_counts(board: &amp;Board) -&gt; Vec&lt;Vec&lt;usize&gt;&gt; {<br>    let height = usize::from(board.squares_high);<br>    let width = usize::from(board.squares_wide);<br>    let mut neighbor_counts = vec![vec![0; height]; width];<br>    for (c, row) in neighbor_counts.iter_mut().enumerate() {<br>        for (r, item) in  row.iter_mut().enumerate() {<br>            let mut neighbors = 0;<br>            //Top<br>            if r &gt; 0 {<br>                //T/L<br>                if c &gt; 0 &amp;&amp; board.squares[c-1][r-1] {<br>                    neighbors += 1;<br>                }<br>                //T/C<br>                if board.squares[c][r-1] {<br>                    neighbors += 1;<br>                }<br>                //T/R<br>                if c+1 &lt; width &amp;&amp; board.squares[c+1][r-1] {<br>                    neighbors += 1;<br>                }<br>            }<br>            //Left<br>            if c &gt; 0 &amp;&amp; board.squares[c-1][r] {<br>                neighbors += 1;<br>            }<br>            //Right<br>            if c+1 &lt; width &amp;&amp; board.squares[c+1][r] {<br>                neighbors += 1;<br>            }<br>            //Bottom<br>            if r+1 &lt; height {<br>                //B/L<br>                if c &gt; 0 &amp;&amp; board.squares[c-1][r+1] {<br>                    neighbors += 1;<br>                }<br>                //B/C<br>                if board.squares[c][r+1] {<br>                    neighbors += 1;<br>                }<br>                //B/R<br>                if c+1 &lt; width &amp;&amp; board.squares[c+1][r+1] {<br>                    neighbors += 1;<br>                }<br>            }<br>            *item = neighbors;<br>        }<br>    }<br>    neighbor_counts<br>}</pre><p>Now instead of our boring back and forth we can update the board using these rules!</p><pre>//main.rs<br>//Update the board for every entity with both a backgroundcolor and a gridlocation..=<br>fn update_board(mut query: Query&lt;(&amp;mut BackgroundColor, &amp;GridLocation)&gt;, mut board: ResMut&lt;Board&gt;) {<br>    //Fetch the neighbor counts.<br>    let neighbor_counts = get_alive_neighbor_counts(board.as_ref());<br>    for (mut color, grid_loc) in &amp;mut query {<br>        let c = usize::from(grid_loc.column);<br>        let r = usize::from(grid_loc.row);<br>        let cur = board.squares[c][r];<br>        let n = neighbor_counts[c][r];<br>        let mut new_state = cur;<br>        if cur {<br>            // Live cell<br>            //fewer than two live neighbours dies, as if by underpopulation.<br>            if n &lt; 2 {<br>                //Underpop<br>                new_state = false;<br>            }<br>            //two or three live neighbours lives on to the next generation.<br>            if n == 2 || n == 3 {<br>                //We live!<br>                new_state = true;<br>            }<br>            //more than three live neighbours dies, as if by overpopulation.<br>            if n &gt; 3 {<br>                //Overpop<br>                new_state = false;<br>            }<br>        } else {<br>            // Dead Cell<br>            //exactly three live neighbours becomes a live cell, as if by reproduction.<br>            if n == 3 {<br>                //breeeed<br>                new_state = true;<br>            }<br>        }<br>        //Update the data<br>        board.squares[c][r] = new_state;<br>        if new_state {<br>            *color = Color::BLACK.into();<br>        } else {<br>            *color = Color::WHITE.into();<br>        }<br>    }<br>}</pre><p>Alright — Execute things with cargo run</p><p>NICE! Looks like we&#39;re movin’! After a while you’ll start to see the checkerboard pattern disappear &amp; likely some patterns begin to stabilize. We can then change it up a bit with the mouse!</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/796/1*BPE2dpC4lMlkUsmUzg9WEg.gif" /></figure><p>Here’s the full main.rs</p><pre>//main.rs<br>#![warn(clippy::pedantic)]<br><br>use bevy::prelude::*;<br><br>//Default for the tile sizes.<br>const TILE_SIZE: u16 = 40;<br>const UPDATE_RATE_SEC: f64 = 0.5;<br><br>#[derive(Resource)]<br>struct Board {<br>    squares_wide: u16,<br>    squares_high: u16,<br>    squares: Vec&lt;Vec&lt;bool&gt;&gt;,<br>}<br><br>#[derive(Component, Debug)]<br>struct GridLocation {<br>    row: u16,<br>    column: u16<br>}<br><br>fn main() {<br>    println!(&quot;Bevy app starting!&quot;);<br>    let cols = 20;<br>    let rows = 20;<br>    // Create a 2d vector where every other square is on or off.<br>    // This is equivalent to a nested for loop over cols then row elements.<br>    let board_state = (0..cols).map(|col| <br>        (0..rows).map(|row| <br>            (col + row) % 2 == 0)<br>            .collect())<br>    .collect();<br>    let board = Board {squares_wide: cols, squares_high: rows, squares: board_state};<br>    let window_width = TILE_SIZE * board.squares_wide;<br>    let window_height =  TILE_SIZE * board.squares_high;<br>    App::new()<br>        .add_plugins(<br>            DefaultPlugins.set(WindowPlugin {<br>                primary_window: Some(Window {<br>                    title: &quot;Conway&#39;s Game of Life&quot;.into(),<br>                    resolution: (f32::from(window_width), f32::from(window_height)).into(),<br>                    ..default()<br>                }),<br>                ..default()<br>            })<br>        )<br>        .insert_resource(board)<br>        .insert_resource(Time::&lt;Fixed&gt;::from_seconds(UPDATE_RATE_SEC))<br>        .add_systems(FixedUpdate, update_board)<br>        .add_systems(Startup, initial_setup)<br>        .add_systems(Update, button_system)<br>        .run();<br>}<br><br>fn initial_setup(mut commands: Commands, board: Res&lt;Board&gt;) {<br>    commands.spawn(Camera2dBundle::default());<br>    //Button style<br>    let button_style = Style {<br>        display: Display::Grid,<br>        justify_content: JustifyContent::Center,<br>        align_items: AlignItems::Center,<br>        ..default()<br>    };<br>    //Draw the grid layout!<br>    commands<br>        .spawn(NodeBundle {<br>            style: Style {<br>                // Create a grid layout, at 100% of the parent element<br>                // Height and width.<br>                display: Display::Grid,<br>                width: Val::Percent(100.0),<br>                height: Val::Percent(100.0),<br>                grid_template_columns: vec![<br>                    GridTrack::auto(); usize::from(board.squares_wide)<br>                ],<br>                grid_template_rows: vec![<br>                    GridTrack::auto(); usize::from(board.squares_high)<br>                ],<br>                ..default()<br>            },<br>            background_color: BackgroundColor(Color::WHITE),<br>            ..default()<br>        })<br>        .with_children(|builder| {<br>            //Every other will be black or white!<br>            for c in 0..board.squares_wide {<br>                for r in 0..board.squares_high {<br>                    let color = if board.squares[usize::from(c)][usize::from(r)] {<br>                        Color::BLACK<br>                    } else {<br>                        Color::WHITE<br>                    };<br>                    let grid_loc = GridLocation {column: c, row: r};<br>                    builder.spawn(<br>                        (ButtonBundle {<br>                            style: button_style.clone(),<br>                            background_color: BackgroundColor(color),<br>                            ..default()<br>                        }, grid_loc)<br>                    );<br>                }<br>            }<br>        });<br>}<br><br>#[allow(clippy::type_complexity)]<br>fn button_system(mut interaction_query: Query&lt;<br>    (<br>        &amp;Interaction,<br>        &amp;mut BackgroundColor,<br>        &amp;GridLocation<br>    ),<br>    (Changed&lt;Interaction&gt;, With&lt;Button&gt;),<br>&gt;, mut board: ResMut&lt;Board&gt;) {<br>    for (interaction, mut color, grid_loc) in &amp;mut interaction_query {<br>        match *interaction {<br>            Interaction::Pressed =&gt; {<br>                let r = usize::from(grid_loc.row);<br>                let c = usize::from(grid_loc.column);<br>                //Get the game state.<br>                let cur = board.squares[c][r];<br>                println!(&quot;Button pressed at ({c},{r}) -- Currently:{cur}&quot;);<br><br>                if cur { //Alive to dead<br>                    *color = Color::WHITE.into();<br>                }<br>                else {<br>                    *color = Color::BLACK.into();<br>                }<br>                board.squares[c][r] = !cur;<br>            },<br>            Interaction::Hovered | Interaction::None =&gt; {},<br>        }<br>    }<br>}<br><br>fn update_board(mut query: Query&lt;(&amp;mut BackgroundColor, &amp;GridLocation)&gt;, mut board: ResMut&lt;Board&gt;) {<br>    //Fetch the neighbor counts.<br>    let neighbor_counts = get_alive_neighbor_counts(board.as_ref());<br>    for (mut color, grid_loc) in &amp;mut query {<br>        let c = usize::from(grid_loc.column);<br>        let r = usize::from(grid_loc.row);<br>        let cur = board.squares[c][r];<br>        let n = neighbor_counts[c][r];<br>        let mut new_state = cur;<br>        if cur {<br>            // Live cell<br>            //fewer than two live neighbours dies, as if by underpopulation.<br>            if n &lt; 2 {<br>                //Underpop<br>                new_state = false;<br>            }<br>            //two or three live neighbours lives on to the next generation.<br>            if n == 2 || n == 3 {<br>                //We live!<br>                new_state = true;<br>            }<br>            //more than three live neighbours dies, as if by overpopulation.<br>            if n &gt; 3 {<br>                //Overpop<br>                new_state = false;<br>            }<br>        } else {<br>            // Dead Cell<br>            //exactly three live neighbours becomes a live cell, as if by reproduction.<br>            if n == 3 {<br>                //breeeed<br>                new_state = true;<br>            }<br>        }<br>        //Update the data<br>        board.squares[c][r] = new_state;<br>        if new_state {<br>            *color = Color::BLACK.into();<br>        } else {<br>            *color = Color::WHITE.into();<br>        }<br>    }<br>}<br><br>fn get_alive_neighbor_counts(board: &amp;Board) -&gt; Vec&lt;Vec&lt;usize&gt;&gt; {<br>    let height = usize::from(board.squares_high);<br>    let width = usize::from(board.squares_wide);<br>    let mut neighbor_counts = vec![vec![0; height]; width];<br>    for (c, row) in neighbor_counts.iter_mut().enumerate() {<br>        for (r, item) in  row.iter_mut().enumerate() {<br>            let mut neighbors = 0;<br>            //Top<br>            if r &gt; 0 {<br>                //T/L<br>                if c &gt; 0 &amp;&amp; board.squares[c-1][r-1] {<br>                    neighbors += 1;<br>                }<br>                //T/C<br>                if board.squares[c][r-1] {<br>                    neighbors += 1;<br>                }<br>                //T/R<br>                if c+1 &lt; width &amp;&amp; board.squares[c+1][r-1] {<br>                    neighbors += 1;<br>                }<br>            }<br>            //Left<br>            if c &gt; 0 &amp;&amp; board.squares[c-1][r] {<br>                neighbors += 1;<br>            }<br>            //Right<br>            if c+1 &lt; width &amp;&amp; board.squares[c+1][r] {<br>                neighbors += 1;<br>            }<br>            //Bottom<br>            if r+1 &lt; height {<br>                //B/L<br>                if c &gt; 0 &amp;&amp; board.squares[c-1][r+1] {<br>                    neighbors += 1;<br>                }<br>                //B/C<br>                if board.squares[c][r+1] {<br>                    neighbors += 1;<br>                }<br>                //B/R<br>                if c+1 &lt; width &amp;&amp; board.squares[c+1][r+1] {<br>                    neighbors += 1;<br>                }<br>            }<br>            *item = neighbors;<br>        }<br>    }<br>    neighbor_counts<br>}</pre><p>git commit -a -m &quot;Implement the game logic for life and death.&quot;</p><p>Right on, right on, right on! So we’ve implemented the game logic and can toggle squares on and off <em>if </em>we’re fast enough. However… that doesn’t allow for much time — You can see in the gif my frustration that the deaths happened before I could click fast enough to sustain the population!</p><p>To allow for more thoughtful setting of the board state, let’s add in the ability to allow the user to pause the game logic so we can take our time creating the patterns.</p><p>This will allow the user to create Game of Life shapes like oscillators and gliders!</p><p>Below the oscillators are the top 4 items, and there’s a glider below that moves down and to the right.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/796/1*aPQemNdgp4lOT9FF5UJPAw.gif" /></figure><h3>Taking Keyboard Input + updating GameState.</h3><p>Ok, so our next goal will be to allow the users to hit the space-bar and pause the game progress such that they can click and make their own patterns with enough time without the life rules kicking in and killing off some poor square too early. For this, we will use the built-in bevy concept of a State. States are built into many features of the Bevy engine and allow us to run or <em>not </em>run certain systems depending on the current state.</p><p>We’ll create a GameState enum, deriving many traits (including States -Required by bevy). We also need to set the default Enum state the game will initially be in when we add the state to the app.</p><pre>//main.rs<br>//Above the Board struct.<br>#[derive(Debug, Default, Clone, Eq, PartialEq, Hash, States)]<br>enum GameState {<br>    #[default]<br>    Running,<br>    Paused,<br>}</pre><p>Then we add the state to the app and we can convert the update_board function to be contingent on the Running gamestate.</p><pre>//main.rs main function, after the insert_resources statements.<br>    .add_state::&lt;GameState&gt;()<br>//Replace the current single FixedUpdate system<br>    .add_systems(FixedUpdate, update_board.run_if(in_state(GameState::Running)))</pre><p>We then can add a keyboard_system that’s similar in many ways to the button_system. For state management, we will need to modify what state the game will be in next iteration, not the state we’re currently in, so we modify the NextState&lt;GameState&gt; we receive.</p><pre>//main.rs<br>// Below the existing button_system<br>#[allow(clippy::needless_pass_by_value)]<br>fn keyboard_system(keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;, game_state: Res&lt;State&lt;GameState&gt;&gt;, mut next_game_state: ResMut&lt;NextState&lt;GameState&gt;&gt;) {<br>    if keyboard_input.just_pressed(KeyCode::Space) {<br>        match game_state.to_owned() {<br>            GameState::Running =&gt; {<br>                println!(&quot;Pausing&quot;);<br>                next_game_state.set(GameState::Paused);<br>            },<br>            GameState::Paused =&gt; {<br>                println!(&quot;Running&quot;);<br>                next_game_state.set(GameState::Running);<br>            },<br>        }<br>    }<br>}</pre><p>Sweet — this keyboard system now will toggle the game between running and paused. The only method currently contingent on <strong>Running</strong> it is the update_board function that runs the game rules.</p><pre>//main.rs<br>// main function, add the keyboard_system on update after button_system<br>.add_systems(Update, keyboard_system)</pre><p>Now, how about we add in the ability to clear the board when the “C” key is pressed, that way if we want to start fresh, we don’t have to click off all the black squares. Ok, should be easy enough, we already have the keyboard event handler, however we’ll need access to the game board as well.</p><pre>#[allow(clippy::needless_pass_by_value)]<br>fn keyboard_system(keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;, game_state: Res&lt;State&lt;GameState&gt;&gt;, mut next_game_state: ResMut&lt;NextState&lt;GameState&gt;&gt;, <br>    mut board: ResMut&lt;Board&gt;) {<br>    if keyboard_input.just_pressed(KeyCode::Space) {<br>        match game_state.to_owned() {<br>            GameState::Running =&gt; {<br>                println!(&quot;Pausing&quot;);<br>                next_game_state.set(GameState::Paused);<br>            },<br>            GameState::Paused =&gt; {<br>                println!(&quot;Running&quot;);<br>                next_game_state.set(GameState::Running);<br>            },<br>        }<br>    }<br>    if keyboard_input.just_pressed(KeyCode::C) {<br>        println!(&quot;Clear&quot;);<br>        for c in 0..usize::from(board.squares_wide) {<br>            for r in 0..usize::from(board.squares_high) {<br>                board.squares[c][r] = false;<br>            }<br>        }<br>    }<br>}</pre><p>If you execute cargo run it pauses fine, but there’s some odd behavior with clear — if it’s paused, we need to resume before the clear happens.</p><p>Our first reflex to fix this might be to add the same queries on color and grid_loc like we have elsewhere into the keyboard system… but when doing so, we might take a step back and realize we’re doing this whole “update the square color” in an awful lot of places. Let’s pull out the drawing into it’s own system.</p><pre>//main.rs<br>// After update_board<br>#[allow(clippy::needless_pass_by_value)]<br>fn draw_board(mut query: Query&lt;(&amp;mut BackgroundColor, &amp;GridLocation)&gt;, board: Res&lt;Board&gt;) {<br>    for (mut color, grid_loc) in &amp;mut query {<br>        let alive = board.squares[grid_loc.column][grid_loc.row];<br>        if alive {<br>            *color = Color::BLACK.into();<br>        } else {<br>            *color = Color::WHITE.into();<br>        }<br>    }<br>}</pre><p>We then should add it in as a system, but we also have two other Update scheduled systems — for this we’ll use a slightly different way to add them in. We’ll use a chained tuple on update as shown here:</p><pre>//main.rs main function:<br>// Remove all add_systems(Update... lines and replace with:<br>.add_systems(Update, (button_system, keyboard_system, draw_board).chain())</pre><p>Now, this will cause a bit of a different behavior in our system — It will guarantee for the Update scheduled events, that the systems that are in the chained tuple will be executed in the order they are listed, so button, keyboard, then draw. This allows the board to be cleared before the board may be drawn. Out of order in this case isn’t hugely impactful as we would update on the next Update tick, which is rapid, but there are other things later that will benefit from the user input being before the drawing phase.</p><p>If you run it now you should see the board clear properly, even if paused.</p><p>Before we commit we should also remove the other spots we currently set the UX color (like in update_board). This will also allow us to prune some method parameters.</p><p>Updated update_board</p><pre>fn update_board(mut query: Query&lt;&amp;GridLocation&gt;, mut board: ResMut&lt;Board&gt;) {<br>    //Fetch the neighbor counts.<br>    let neighbor_counts = get_alive_neighbor_counts(board.as_ref());<br>    for grid_loc in &amp;mut query {<br>        let c = usize::from(grid_loc.column);<br>        let r = usize::from(grid_loc.row);<br>        let cur = board.squares[c][r];<br>        let n = neighbor_counts[c][r];<br>        let mut new_state = cur;<br>        if cur {<br>            // Live cell<br>            //fewer than two live neighbours dies, as if by underpopulation.<br>            if n &lt; 2 {<br>                //Underpop<br>                new_state = false;<br>            }<br>            //two or three live neighbours lives on to the next generation.<br>            if n == 2 || n == 3 {<br>                //We live!<br>                new_state = true;<br>            }<br>            //more than three live neighbours dies, as if by overpopulation.<br>            if n &gt; 3 {<br>                //Overpop<br>                new_state = false;<br>            }<br>        } else {<br>            // Dead Cell<br>            //exactly three live neighbours becomes a live cell, as if by reproduction.<br>            if n == 3 {<br>                //breeeed<br>                new_state = true;<br>            }<br>        }<br>        //Update the data<br>        board.squares[c][r] = new_state;<br>    }<br>}</pre><p>updated button_system</p><pre>#[allow(clippy::type_complexity)]<br>fn button_system(mut interaction_query: Query&lt;<br>    (<br>        &amp;Interaction,<br>        &amp;GridLocation,<br>    ),<br>    (Changed&lt;Interaction&gt;, With&lt;Button&gt;),<br>&gt;, mut board: ResMut&lt;Board&gt;) {<br>    for (interaction, grid_loc) in &amp;mut interaction_query {<br>        match *interaction {<br>            Interaction::Pressed =&gt; {<br>                let r = usize::from(grid_loc.row);<br>                let c = usize::from(grid_loc.column);<br>                //Get the game state.<br>                let cur = board.squares[c][r];<br>                println!(&quot;Button pressed at ({c},{r}) -- Currently:{cur}&quot;);<br>                board.squares[c][r] = !cur;<br>            },<br>            Interaction::Hovered | Interaction::None =&gt; {},<br>        }<br>    }<br>}</pre><p>A major strength of ECS is that is allows this type of separation of components from each other. The above is a concrete example where we can prune any care about UX from the keyboard_system, mouse_system, and update_board functions but still maintain the same functionality. This is useful if we wanted to add some feature where perhaps we want to only draw a subset of the screen, or change the UX experience to something like a <a href="https://github.com/ratatui-org/ratatui">ratatui </a>console and the code changes may only be required in the draw_board function.</p><p>Alright — lots of updates, here’s the full main.rs</p><pre>//main.rs<br>#![warn(clippy::pedantic)]<br><br>use bevy::prelude::*;<br><br>//Default for the tile sizes.<br>const TILE_SIZE: u16 = 40;<br>const UPDATE_RATE_SEC: f64 = 0.5;<br><br>#[derive(Debug, Default, Clone, Eq, PartialEq, Hash, States)]<br>enum GameState {<br>    #[default]<br>    Running,<br>    Paused,<br>}<br><br>#[derive(Resource)]<br>struct Board {<br>    squares_wide: u16,<br>    squares_high: u16,<br>    squares: Vec&lt;Vec&lt;bool&gt;&gt;,<br>}<br><br>#[derive(Component, Debug)]<br>struct GridLocation {<br>    row: u16,<br>    column: u16<br>}<br><br>fn main() {<br>    println!(&quot;Bevy app starting!&quot;);<br>    let cols = 20;<br>    let rows = 20;<br>    // Create a 2d vector where every other square is on or off.<br>    // This is equivalent to a nested for loop over cols then row elements.<br>    let board_state = (0..cols).map(|col| <br>        (0..rows).map(|row| <br>            (col + row) % 2 == 0)<br>            .collect())<br>    .collect();<br>    let board = Board {squares_wide: cols, squares_high: rows, squares: board_state};<br>    let window_width = TILE_SIZE * board.squares_wide;<br>    let window_height =  TILE_SIZE * board.squares_high;<br>    App::new()<br>        .add_plugins(<br>            DefaultPlugins.set(WindowPlugin {<br>                primary_window: Some(Window {<br>                    title: &quot;Conway&#39;s Game of Life&quot;.into(),<br>                    resolution: (f32::from(window_width), f32::from(window_height)).into(),<br>                    ..default()<br>                }),<br>                ..default()<br>            })<br>        )<br>        .insert_resource(board)<br>        .insert_resource(Time::&lt;Fixed&gt;::from_seconds(UPDATE_RATE_SEC))<br>        .add_state::&lt;GameState&gt;()<br>        .add_systems(FixedUpdate, update_board.run_if(in_state(GameState::Running)))<br>        .add_systems(Startup, initial_setup)<br>        .add_systems(Update, (button_system, keyboard_system, draw_board).chain())<br>        .run();<br>}<br><br>#[allow(clippy::needless_pass_by_value)]<br>fn initial_setup(mut commands: Commands, board: Res&lt;Board&gt;) {<br>    commands.spawn(Camera2dBundle::default());<br>    //Button style<br>    let button_style = Style {<br>        display: Display::Grid,<br>        justify_content: JustifyContent::Center,<br>        align_items: AlignItems::Center,<br>        ..default()<br>    };<br>    //Draw the grid layout!<br>    commands<br>        .spawn(NodeBundle {<br>            style: Style {<br>                // Create a grid layout, at 100% of the parent element<br>                // Height and width.<br>                display: Display::Grid,<br>                width: Val::Percent(100.0),<br>                height: Val::Percent(100.0),<br>                grid_template_columns: vec![<br>                    GridTrack::auto(); usize::from(board.squares_wide)<br>                ],<br>                grid_template_rows: vec![<br>                    GridTrack::auto(); usize::from(board.squares_high)<br>                ],<br>                ..default()<br>            },<br>            background_color: BackgroundColor(Color::WHITE),<br>            ..default()<br>        })<br>        .with_children(|builder| {<br>            //Every other will be black or white!<br>            for c in 0..board.squares_wide {<br>                for r in 0..board.squares_high {<br>                    let color = if board.squares[usize::from(c)][usize::from(r)] {<br>                        Color::BLACK<br>                    } else {<br>                        Color::WHITE<br>                    };<br>                    let grid_loc = GridLocation {column: c, row: r};<br>                    builder.spawn(<br>                        (ButtonBundle {<br>                            style: button_style.clone(),<br>                            background_color: BackgroundColor(color),<br>                            ..default()<br>                        }, grid_loc)<br>                    );<br>                }<br>            }<br>        });<br>}<br><br>#[allow(clippy::type_complexity)]<br>fn button_system(mut interaction_query: Query&lt;<br>    (<br>        &amp;Interaction,<br>        &amp;GridLocation,<br>    ),<br>    (Changed&lt;Interaction&gt;, With&lt;Button&gt;),<br>&gt;, mut board: ResMut&lt;Board&gt;) {<br>    for (interaction, grid_loc) in &amp;mut interaction_query {<br>        match *interaction {<br>            Interaction::Pressed =&gt; {<br>                let r = usize::from(grid_loc.row);<br>                let c = usize::from(grid_loc.column);<br>                //Get the game state.<br>                let cur = board.squares[c][r];<br>                println!(&quot;Button pressed at ({c},{r}) -- Currently:{cur}&quot;);<br>                board.squares[c][r] = !cur;<br>            },<br>            Interaction::Hovered | Interaction::None =&gt; {},<br>        }<br>    }<br>}<br><br>#[allow(clippy::needless_pass_by_value)]<br>fn keyboard_system(keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;, game_state: Res&lt;State&lt;GameState&gt;&gt;, mut next_game_state: ResMut&lt;NextState&lt;GameState&gt;&gt;, <br>    mut board: ResMut&lt;Board&gt;) {<br>    if keyboard_input.just_pressed(KeyCode::Space) {<br>        match game_state.to_owned() {<br>            GameState::Running =&gt; {<br>                println!(&quot;Pausing&quot;);<br>                next_game_state.set(GameState::Paused);<br>            },<br>            GameState::Paused =&gt; {<br>                println!(&quot;Running&quot;);<br>                next_game_state.set(GameState::Running);<br>            },<br>        }<br>    }<br>    if keyboard_input.just_pressed(KeyCode::C) {<br>        println!(&quot;Clear&quot;);<br>        for c in 0..usize::from(board.squares_wide) {<br>            for r in 0..usize::from(board.squares_high) {<br>                board.squares[c][r] = false;<br>            }<br>        }<br>    }<br>}<br><br>fn update_board(mut query: Query&lt;&amp;GridLocation&gt;, mut board: ResMut&lt;Board&gt;) {<br>    //Fetch the neighbor counts.<br>    let neighbor_counts = get_alive_neighbor_counts(board.as_ref());<br>    for grid_loc in &amp;mut query {<br>        let c = usize::from(grid_loc.column);<br>        let r = usize::from(grid_loc.row);<br>        let cur = board.squares[c][r];<br>        let n = neighbor_counts[c][r];<br>        let mut new_state = cur;<br>        if cur {<br>            // Live cell<br>            //fewer than two live neighbours dies, as if by underpopulation.<br>            if n &lt; 2 {<br>                //Underpop<br>                new_state = false;<br>            }<br>            //two or three live neighbours lives on to the next generation.<br>            if n == 2 || n == 3 {<br>                //We live!<br>                new_state = true;<br>            }<br>            //more than three live neighbours dies, as if by overpopulation.<br>            if n &gt; 3 {<br>                //Overpop<br>                new_state = false;<br>            }<br>        } else {<br>            // Dead Cell<br>            //exactly three live neighbours becomes a live cell, as if by reproduction.<br>            if n == 3 {<br>                //breeeed<br>                new_state = true;<br>            }<br>        }<br>        //Update the data<br>        board.squares[c][r] = new_state;<br>    }<br>}<br><br>#[allow(clippy::needless_pass_by_value)]<br>fn draw_board(mut query: Query&lt;(&amp;mut BackgroundColor, &amp;GridLocation)&gt;, board: Res&lt;Board&gt;) {<br>    for (mut color, grid_loc) in &amp;mut query {<br>        let alive = board.squares[usize::from(grid_loc.column)][usize::from(grid_loc.row)];<br>        if alive {<br>            *color = Color::BLACK.into();<br>        } else {<br>            *color = Color::WHITE.into();<br>        }<br>    }<br>}<br><br>fn get_alive_neighbor_counts(board: &amp;Board) -&gt; Vec&lt;Vec&lt;usize&gt;&gt; {<br>    let height = usize::from(board.squares_high);<br>    let width = usize::from(board.squares_wide);<br>    let mut neighbor_counts = vec![vec![0; height]; width];<br>    for (c, row) in neighbor_counts.iter_mut().enumerate() {<br>        for (r, item) in  row.iter_mut().enumerate() {<br>            let mut neighbors = 0;<br>            //Top<br>            if r &gt; 0 {<br>                //T/L<br>                if c &gt; 0 &amp;&amp; board.squares[c-1][r-1] {<br>                    neighbors += 1;<br>                }<br>                //T/C<br>                if board.squares[c][r-1] {<br>                    neighbors += 1;<br>                }<br>                //T/R<br>                if c+1 &lt; width &amp;&amp; board.squares[c+1][r-1] {<br>                    neighbors += 1;<br>                }<br>            }<br>            //Left<br>            if c &gt; 0 &amp;&amp; board.squares[c-1][r] {<br>                neighbors += 1;<br>            }<br>            //Right<br>            if c+1 &lt; width &amp;&amp; board.squares[c+1][r] {<br>                neighbors += 1;<br>            }<br>            //Bottom<br>            if r+1 &lt; height {<br>                //B/L<br>                if c &gt; 0 &amp;&amp; board.squares[c-1][r+1] {<br>                    neighbors += 1;<br>                }<br>                //B/C<br>                if board.squares[c][r+1] {<br>                    neighbors += 1;<br>                }<br>                //B/R<br>                if c+1 &lt; width &amp;&amp; board.squares[c+1][r+1] {<br>                    neighbors += 1;<br>                }<br>            }<br>            *item = neighbors;<br>        }<br>    }<br>    neighbor_counts<br>}</pre><p>Let’s commit for good measure!</p><p>git commit -a -m “Add ability to pause/resume and clear the board. Refactor the UX setting to be contained in the draw_board function.”</p><h3>Iteration counter display</h3><p>Next it’d be nice to display a few pieces of info about the game status, like the number of alive or dead squares and the number of iterations since the last start/clear.</p><p>For this we will add additional information into the board resource, and one that represents the current game iteration count. In addition we’ll add some no-member structs we’ll use later when spawning our new text areas.</p><pre>//main.rs<br>//Add alive_squares to the Board.<br>#[derive(Resource)]<br>struct Board {<br>    squares_wide: u16,<br>    squares_high: u16,<br>    squares: Vec&lt;Vec&lt;bool&gt;&gt;,<br>    alive_squares: usize,<br>}<br><br>//Add a new iterations counter to a GameMetadata below board.<br>#[derive(Resource, Default)]<br>struct GameMetadata {<br>    iterations: usize<br>}<br><br>#[derive(Component)]<br>struct IterationText;<br><br>#[derive(Component)]<br>struct GameStateText;<br><br>//main.rs main function<br>// Add the alive_squares to be 1/2 of the cols * rows.<br>let board = Board {squares_wide: cols, squares_high: rows, squares: board_state, alive_squares: usize::from(cols) * usize::from(rows) / 2};<br>let game_metadata = GameMetadata::default();<br>// Add game_metadata after the board insertion.<br>.insert_resource(game_metadata)<br></pre><p>Next we’ll add a new UX element for a status bar at the bottom of the game.</p><p>In the area we already declare some of the consts, add a pixel height of the status bar as well as resize the window to accomodate out new space.</p><pre>//main.rs<br>// Below TITLE_SIZE<br>const STATUS_BAR_PX: f32 = 40.0;<br><br>// In the main function, change the window_height variable to also include the STATUS_BAR_PX<br>let window_width = f32::from(TILE_SIZE * board.squares_wide);<br>let window_height =  f32::from(TILE_SIZE * board.squares_high) + STATUS_BAR_PX;<br>// Update the resolution aspect of the window setting to no longer require f32::from<br>resolution: (window_width, window_height).into(),</pre><p>Previously our game grid layout was added to the base world at 100% height and width, now we need to add an additional status bar below the game grid, so we’ll add another layer of grid layout, this time with 1 column and two rows. In addition, we will use a fixed size for the status bar row, and configure the game grid row to take up all the remaining space (base height <em>minus </em>the fixed number of pixels).</p><p>Here’s a high level view of what we’re going to change to.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*YMP9Pnq5PwpZ_Dab7LRnaw.png" /></figure><p>First thing we spawn will be the 1 column, 2 row grid layout.</p><pre>//main.rs<br>//Update initial_setup method signature to also take in the GameMetadata.<br>#[allow(clippy::needless_pass_by_value)]<br>fn initial_setup(mut commands: Commands, board: Res&lt;Board&gt;, metadata: ResMut&lt;GameMetadata&gt;) {<br>//&lt;...&gt;<br>// replace the spawn of the prior game grid layout.<br>    commands<br>        .spawn(NodeBundle {<br>            style: Style {<br>                //Create a grid layout,<br>                display: Display::Grid,<br>                width: Val::Percent(100.0),<br>                height: Val::Percent(100.0),<br>                grid_template_columns: vec![<br>                    GridTrack::auto()<br>                ],<br>                //Top Row will take up all the space after the bottom row is complete.<br>                grid_template_rows: vec![<br>                    GridTrack::flex(1.0), GridTrack::px(STATUS_BAR_PX)<br>                ],<br>                ..default()<br>            },<br>            background_color: BackgroundColor(Color::WHITE),<br>            ..default()<br>        })</pre><p>This grid layout we just added fills 100% of the base and with GridTrack::px we add a fixed element size for the bottom row.</p><p>We then use this to add children to it, which will be the grid layout like before, and a new status bar item with some tuples of TextBundles as well as the components we created above.</p><p>The two new TextBundles will represent the game state (paused, etc) and the iteration count + alive square counts.</p><pre>//main.rs<br>//initial_setup below the new gridlayout.<br>        .with_children(|builder| {<br>            //Game Area<br>            builder.spawn(NodeBundle {<br>                style: Style {<br>                    //Create a grid layout,<br>                    display: Display::Grid,<br>                    width: Val::Percent(100.0),<br>                    height: Val::Percent(100.0),<br>                    grid_template_columns: vec![<br>                        GridTrack::auto(); usize::from(board.squares_wide)<br>                    ],<br>                    grid_template_rows: vec![<br>                        GridTrack::auto(); usize::from(board.squares_high)<br>                    ],<br>                    ..default()<br>                },<br>                background_color: BackgroundColor(Color::WHITE),<br>                ..default()<br>            })<br>            .with_children(|game_area_builder| {<br>                //Every other will be black or white!<br>                for c in 0..board.squares_wide {<br>                    for r in 0..board.squares_high {<br>                        //Set the color based on the board state.<br>                        let color = if board.squares[usize::from(c)][usize::from(r)] {<br>                            Color::BLACK<br>                        } else {<br>                            Color::WHITE<br>                        };<br>                        let grid_loc = GridLocation {column: c, row: r};<br>                        game_area_builder.spawn(<br>                            (ButtonBundle {<br>                                style: button_style.clone(),<br>                                background_color: BackgroundColor(color),<br>                                ..default()<br>                            }, grid_loc)<br>                        );<br>                    }<br>                }<br>            });<br>            //Status Tray<br>            builder.spawn(NodeBundle {<br>                style: Style {<br>                    display: Display::Grid,<br>                    padding: UiRect::all(Val::Px(6.0)),<br>                    grid_template_rows: vec![<br>                        GridTrack::auto()<br>                    ],<br>                    //Left slot, right slot.<br>                    grid_template_columns: vec![<br>                        GridTrack::auto(), GridTrack::auto()<br>                    ],<br>                    ..default()<br>                },<br>                ..default()<br>            })<br>            .with_children(|tray_builder| {<br>                tray_builder.spawn((TextBundle::from_section(<br>                    &quot;Running: [space] to pause, [c] to clear.&quot;,<br>                    TextStyle {<br>                        font: Handle::default(),<br>                        font_size: 20.0,<br>                        color: Color::BLACK,<br>                    },<br>                ), GameStateText));<br>                tray_builder.spawn((TextBundle::from_section(<br>                    format!(&quot;Iter:{}; Alive:{}&quot;, metadata.iterations, board.alive_squares),<br>                    TextStyle {<br>                        font: Handle::default(),<br>                        font_size: 20.0,<br>                        color: Color::BLACK,<br>                    },<br>                ).with_text_alignment(TextAlignment::Right), IterationText));<br>            });<br>        });</pre><p>The reason we added the new IterationText and StatusText components is so we can query for these specific text fields when we want to update their values after the game is paused or an iteration tick occurred. For this text update we’ll add a new system. This new system queries for any Text element with IterationText associated to modify the text on iteration update.</p><p>For the status_bar_text_update we require the two Text entities as the query params, one for the GameStateText and the other for IterationText. If we just add two different query params Bevy prevents it. This is because Bevy has no guarantee we didn’t create entities that may share a Component. If we has added both GameStateText and IterationText we would have two mutable references to the same variable which would violate the guarantees of safe rust.</p><p>The solution to this is the <a href="https://docs.rs/bevy/latest/bevy/prelude/struct.ParamSet.html">ParamSet</a> which uses parameter numbering and the borrow checker to ensure we only have a mutable reference to one of the parameters at a time. There are some pretty good examples and explanations in the <a href="https://docs.rs/bevy/latest/bevy/prelude/struct.ParamSet.html">ParamSet</a> docs.</p><pre>//main.rs<br>// Below the keyboard system<br>#[allow(clippy::type_complexity, clippy::needless_pass_by_value)]<br>fn status_bar_text_update(mut text_params: ParamSet&lt;(Query&lt;&amp;mut Text, With&lt;GameStateText&gt;&gt;, Query&lt;&amp;mut Text, With&lt;IterationText&gt;&gt;)&gt;, board: Res&lt;Board&gt;,<br>    metadata: Res&lt;GameMetadata&gt;, game_state: Res&lt;State&lt;GameState&gt;&gt;) {<br>    let mut game_state_query = text_params.p0();<br>    match game_state.to_owned() {<br>        GameState::Running =&gt; {<br>            game_state_query.single_mut().sections[0].value = &quot;Running: [space] to pause, [c] to clear.&quot;.to_string();<br>        },<br>        GameState::Paused =&gt; {<br>            game_state_query.single_mut().sections[0].value = &quot;Paused: [space] to resume, [c] to clear, [n] for next.&quot;.to_string();<br>        },<br>    }<br>    let mut iter_state_query = text_params.p1();<br>    let new_text = format!(&quot;Iter:{}; Alive:{}&quot;, metadata.iterations, board.alive_squares);<br>    iter_state_query.single_mut().sections[0].value = new_text;<br>}<br>// in main() where the systems are intitialized, update the Update system addition<br>.add_systems(Update, (button_system, keyboard_system, draw_board, status_bar_text_update).chain())<br></pre><p>We also have to change the square count and increment the iteration counter in both update_board, the keyboard_system, and button_system functions.</p><pre>//main.rs<br>// Add the new metadata resource to update_board.<br>// Count up the alive squares and increment the iterations.<br>fn update_board(mut query: Query&lt;&amp;GridLocation&gt;, mut board: ResMut&lt;Board&gt;, mut metadata: ResMut&lt;GameMetadata&gt;) {<br>    //Fetch the neighbor counts.<br>    let neighbor_counts = get_alive_neighbor_counts(board.as_ref());<br>    let mut alive_count = 0;<br>    for grid_loc in &amp;mut query {<br>        let c = usize::from(grid_loc.column);<br>        let r = usize::from(grid_loc.row);<br>        let cur = board.squares[c][r];<br>        let n = neighbor_counts[c][r];<br>        let mut new_state = cur;<br>        if cur {<br>            // Live cell<br>            //fewer than two live neighbours dies, as if by underpopulation.<br>            if n &lt; 2 {<br>                //Underpop<br>                new_state = false;<br>            }<br>            //two or three live neighbours lives on to the next generation.<br>            if n == 2 || n == 3 {<br>                //We live!<br>                new_state = true;<br>            }<br>            //more than three live neighbours dies, as if by overpopulation.<br>            if n &gt; 3 {<br>                //Overpop<br>                new_state = false;<br>            }<br>        } else {<br>            // Dead Cell<br>            //exactly three live neighbours becomes a live cell, as if by reproduction.<br>            if n == 3 {<br>                //breeeed<br>                new_state = true;<br>            }<br>        }<br>        if new_state {<br>            alive_count += 1;<br>        }<br>        //Update the data<br>        board.squares[c][r] = new_state;<br>    }<br>    board.alive_squares = alive_count;<br>    metadata.iterations += 1;<br>}<br><br>//Modify the button system to mod the alive count<br>#[allow(clippy::type_complexity)]<br>fn button_system(mut interaction_query: Query&lt;<br>    (<br>        &amp;Interaction,<br>        &amp;GridLocation,<br>    ),<br>    (Changed&lt;Interaction&gt;, With&lt;Button&gt;),<br>&gt;, mut board: ResMut&lt;Board&gt;) {<br>    for (interaction, grid_loc) in &amp;mut interaction_query {<br>        match *interaction {<br>            Interaction::Pressed =&gt; {<br>                let r = usize::from(grid_loc.row);<br>                let c = usize::from(grid_loc.column);<br>                //Get the game state.<br>                let cur = board.squares[c][r];<br>                if cur {<br>                    board.alive_squares -= 1;<br>                } else {<br>                    board.alive_squares += 1;<br>                }<br>                println!(&quot;Button pressed at ({c},{r}) -- Currently:{cur}&quot;);<br>                board.squares[c][r] = !cur;<br>            },<br>            Interaction::Hovered | Interaction::None =&gt; {},<br>        }<br>    }<br>}<br><br>//And the keyboard_system to zero the alive_squares on clear.<br>#[allow(clippy::needless_pass_by_value)]<br>fn keyboard_system(keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;, game_state: Res&lt;State&lt;GameState&gt;&gt;, mut next_game_state: ResMut&lt;NextState&lt;GameState&gt;&gt;, <br>    mut board: ResMut&lt;Board&gt;) {<br>    if keyboard_input.just_pressed(KeyCode::Space) {<br>        match game_state.to_owned() {<br>            GameState::Running =&gt; {<br>                println!(&quot;Pausing&quot;);<br>                next_game_state.set(GameState::Paused);<br>            },<br>            GameState::Paused =&gt; {<br>                println!(&quot;Running&quot;);<br>                next_game_state.set(GameState::Running);<br>            },<br>        }<br>    }<br>    if keyboard_input.just_pressed(KeyCode::C) {<br>        println!(&quot;Clear&quot;);<br>        for c in 0..usize::from(board.squares_wide) {<br>            for r in 0..usize::from(board.squares_high) {<br>                board.squares[c][r] = false;<br>            }<br>        }<br>        board.alive_squares = 0;<br>    }<br>}</pre><p>Okay now, lots of additions scattered everywhere on that one, let’s do another full main.rs</p><pre>//main.rs<br>#![warn(clippy::pedantic)]<br><br>use bevy::prelude::*;<br><br>//Default for the tile sizes.<br>const TILE_SIZE: u16 = 40;<br>const STATUS_BAR_PX: f32 = 40.0;<br>const UPDATE_RATE_SEC: f64 = 0.5;<br><br>#[derive(Debug, Default, Clone, Eq, PartialEq, Hash, States)]<br>enum GameState {<br>    #[default]<br>    Running,<br>    Paused,<br>}<br><br>#[derive(Resource)]<br>struct Board {<br>    squares_wide: u16,<br>    squares_high: u16,<br>    squares: Vec&lt;Vec&lt;bool&gt;&gt;,<br>    alive_squares: usize,<br>}<br><br>#[derive(Resource, Default)]<br>struct GameMetadata {<br>    iterations: usize<br>}<br><br>#[derive(Component)]<br>struct IterationText;<br><br>#[derive(Component)]<br>struct GameStateText;<br><br>#[derive(Component, Debug)]<br>struct GridLocation {<br>    row: u16,<br>    column: u16<br>}<br><br>fn main() {<br>    println!(&quot;Bevy app starting!&quot;);<br>    let cols = 20;<br>    let rows = 20;<br>    // Create a 2d vector where every other square is on or off.<br>    // This is equivalent to a nested for loop over cols then row elements.<br>    let board_state = (0..cols).map(|col| <br>        (0..rows).map(|row| <br>            (col + row) % 2 == 0)<br>            .collect())<br>    .collect();<br>    let board = Board {squares_wide: cols, squares_high: rows, squares: board_state, alive_squares: usize::from(cols) * usize::from(rows) / 2};<br>    let game_metadata = GameMetadata::default();<br>    let window_width = f32::from(TILE_SIZE * board.squares_wide);<br>    let window_height =  f32::from(TILE_SIZE * board.squares_high) + STATUS_BAR_PX;<br>    App::new()<br>        .add_plugins(<br>            DefaultPlugins.set(WindowPlugin {<br>                primary_window: Some(Window {<br>                    title: &quot;Conway&#39;s Game of Life&quot;.into(),<br>                    resolution: (window_width, window_height).into(),<br>                    ..default()<br>                }),<br>                ..default()<br>            })<br>        )<br>        .insert_resource(board)<br>        .insert_resource(game_metadata)<br>        .insert_resource(Time::&lt;Fixed&gt;::from_seconds(UPDATE_RATE_SEC))<br>        .add_state::&lt;GameState&gt;()<br>        .add_systems(FixedUpdate, update_board.run_if(in_state(GameState::Running)))<br>        .add_systems(Startup, initial_setup)<br>        .add_systems(Update, (button_system, keyboard_system, draw_board, status_bar_text_update).chain())<br>        .run();<br>}<br><br>#[allow(clippy::needless_pass_by_value)]<br>fn initial_setup(mut commands: Commands, board: Res&lt;Board&gt;, metadata: ResMut&lt;GameMetadata&gt;) {<br>    commands.spawn(Camera2dBundle::default());<br>    //Button style<br>    let button_style = Style {<br>        display: Display::Grid,<br>        justify_content: JustifyContent::Center,<br>        align_items: AlignItems::Center,<br>        ..default()<br>    };<br>    //Draw the grid layout!<br>    commands<br>        .spawn(NodeBundle {<br>            style: Style {<br>                //Create a grid layout,<br>                display: Display::Grid,<br>                width: Val::Percent(100.0),<br>                height: Val::Percent(100.0),<br>                grid_template_columns: vec![<br>                    GridTrack::auto()<br>                ],<br>                //Top Row will take up all the space after the bottom row is complete.<br>                grid_template_rows: vec![<br>                    GridTrack::flex(1.0), GridTrack::px(STATUS_BAR_PX)<br>                ],<br>                ..default()<br>            },<br>            background_color: BackgroundColor(Color::WHITE),<br>            ..default()<br>        })<br>        .with_children(|builder| {<br>            //Game Area<br>            builder.spawn(NodeBundle {<br>                style: Style {<br>                    //Create a grid layout,<br>                    display: Display::Grid,<br>                    width: Val::Percent(100.0),<br>                    height: Val::Percent(100.0),<br>                    grid_template_columns: vec![<br>                        GridTrack::auto(); usize::from(board.squares_wide)<br>                    ],<br>                    grid_template_rows: vec![<br>                        GridTrack::auto(); usize::from(board.squares_high)<br>                    ],<br>                    ..default()<br>                },<br>                background_color: BackgroundColor(Color::WHITE),<br>                ..default()<br>            })<br>            .with_children(|game_area_builder| {<br>                //Every other will be black or white!<br>                for c in 0..board.squares_wide {<br>                    for r in 0..board.squares_high {<br>                        //Set the color based on the board state.<br>                        let color = if board.squares[usize::from(c)][usize::from(r)] {<br>                            Color::BLACK<br>                        } else {<br>                            Color::WHITE<br>                        };<br>                        let grid_loc = GridLocation {column: c, row: r};<br>                        game_area_builder.spawn(<br>                            (ButtonBundle {<br>                                style: button_style.clone(),<br>                                background_color: BackgroundColor(color),<br>                                ..default()<br>                            }, grid_loc)<br>                        );<br>                    }<br>                }<br>            });<br>            //Status Tray<br>            builder.spawn(NodeBundle {<br>                style: Style {<br>                    display: Display::Grid,<br>                    padding: UiRect::all(Val::Px(6.0)),<br>                    grid_template_rows: vec![<br>                        GridTrack::auto()<br>                    ],<br>                    //Left slot, right slot.<br>                    grid_template_columns: vec![<br>                        GridTrack::auto(), GridTrack::auto()<br>                    ],<br>                    ..default()<br>                },<br>                ..default()<br>            })<br>            .with_children(|tray_builder| {<br>                tray_builder.spawn((TextBundle::from_section(<br>                    &quot;Running: [space] to pause, [c] to clear.&quot;,<br>                    TextStyle {<br>                        font: Handle::default(),<br>                        font_size: 20.0,<br>                        color: Color::BLACK,<br>                    },<br>                ), GameStateText));<br>                tray_builder.spawn((TextBundle::from_section(<br>                    format!(&quot;Iter:{}; Alive:{}&quot;, metadata.iterations, board.alive_squares),<br>                    TextStyle {<br>                        font: Handle::default(),<br>                        font_size: 20.0,<br>                        color: Color::BLACK,<br>                    },<br>                ).with_text_alignment(TextAlignment::Right), IterationText));<br>            });<br>        });<br>}<br><br>#[allow(clippy::type_complexity)]<br>fn button_system(mut interaction_query: Query&lt;<br>    (<br>        &amp;Interaction,<br>        &amp;GridLocation,<br>    ),<br>    (Changed&lt;Interaction&gt;, With&lt;Button&gt;),<br>&gt;, mut board: ResMut&lt;Board&gt;) {<br>    for (interaction, grid_loc) in &amp;mut interaction_query {<br>        match *interaction {<br>            Interaction::Pressed =&gt; {<br>                let r = usize::from(grid_loc.row);<br>                let c = usize::from(grid_loc.column);<br>                //Get the game state.<br>                let cur = board.squares[c][r];<br>                if cur {<br>                    board.alive_squares -= 1;<br>                } else {<br>                    board.alive_squares += 1;<br>                }<br>                println!(&quot;Button pressed at ({c},{r}) -- Currently:{cur}&quot;);<br>                board.squares[c][r] = !cur;<br>            },<br>            Interaction::Hovered | Interaction::None =&gt; {},<br>        }<br>    }<br>}<br><br>#[allow(clippy::needless_pass_by_value)]<br>fn keyboard_system(keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;, game_state: Res&lt;State&lt;GameState&gt;&gt;, mut next_game_state: ResMut&lt;NextState&lt;GameState&gt;&gt;, <br>    mut board: ResMut&lt;Board&gt;) {<br>    if keyboard_input.just_pressed(KeyCode::Space) {<br>        match game_state.to_owned() {<br>            GameState::Running =&gt; {<br>                println!(&quot;Pausing&quot;);<br>                next_game_state.set(GameState::Paused);<br>            },<br>            GameState::Paused =&gt; {<br>                println!(&quot;Running&quot;);<br>                next_game_state.set(GameState::Running);<br>            },<br>        }<br>    }<br>    if keyboard_input.just_pressed(KeyCode::C) {<br>        println!(&quot;Clear&quot;);<br>        for c in 0..usize::from(board.squares_wide) {<br>            for r in 0..usize::from(board.squares_high) {<br>                board.squares[c][r] = false;<br>            }<br>        }<br>        board.alive_squares = 0;<br>    }<br>}<br><br>#[allow(clippy::type_complexity, clippy::needless_pass_by_value)]<br>fn status_bar_text_update(mut text_params: ParamSet&lt;(Query&lt;&amp;mut Text, With&lt;GameStateText&gt;&gt;, Query&lt;&amp;mut Text, With&lt;IterationText&gt;&gt;)&gt;, board: Res&lt;Board&gt;,<br>    metadata: Res&lt;GameMetadata&gt;, game_state: Res&lt;State&lt;GameState&gt;&gt;) {<br>    let mut game_state_query = text_params.p0();<br>    match game_state.to_owned() {<br>        GameState::Running =&gt; {<br>            game_state_query.single_mut().sections[0].value = &quot;Running: [space] to pause, [c] to clear.&quot;.to_string();<br>        },<br>        GameState::Paused =&gt; {<br>            game_state_query.single_mut().sections[0].value = &quot;Paused: [space] to resume, [c] to clear, [n] for next.&quot;.to_string();<br>        },<br>    }<br>    let mut iter_state_query = text_params.p1();<br>    let new_text = format!(&quot;Iter:{}; Alive:{}&quot;, metadata.iterations, board.alive_squares);<br>    iter_state_query.single_mut().sections[0].value = new_text;<br>}<br><br>fn update_board(mut query: Query&lt;&amp;GridLocation&gt;, mut board: ResMut&lt;Board&gt;, mut metadata: ResMut&lt;GameMetadata&gt;) {<br>    //Fetch the neighbor counts.<br>    let neighbor_counts = get_alive_neighbor_counts(board.as_ref());<br>    let mut alive_count = 0;<br>    for grid_loc in &amp;mut query {<br>        let c = usize::from(grid_loc.column);<br>        let r = usize::from(grid_loc.row);<br>        let cur = board.squares[c][r];<br>        let n = neighbor_counts[c][r];<br>        let mut new_state = cur;<br>        if cur {<br>            // Live cell<br>            //fewer than two live neighbours dies, as if by underpopulation.<br>            if n &lt; 2 {<br>                //Underpop<br>                new_state = false;<br>            }<br>            //two or three live neighbours lives on to the next generation.<br>            if n == 2 || n == 3 {<br>                //We live!<br>                new_state = true;<br>            }<br>            //more than three live neighbours dies, as if by overpopulation.<br>            if n &gt; 3 {<br>                //Overpop<br>                new_state = false;<br>            }<br>        } else {<br>            // Dead Cell<br>            //exactly three live neighbours becomes a live cell, as if by reproduction.<br>            if n == 3 {<br>                //breeeed<br>                new_state = true;<br>            }<br>        }<br>        if new_state {<br>            alive_count += 1;<br>        }<br>        //Update the data<br>        board.squares[c][r] = new_state;<br>    }<br>    board.alive_squares = alive_count;<br>    metadata.iterations += 1;<br>}<br><br>#[allow(clippy::needless_pass_by_value)]<br>fn draw_board(mut query: Query&lt;(&amp;mut BackgroundColor, &amp;GridLocation)&gt;, board: Res&lt;Board&gt;) {<br>    for (mut color, grid_loc) in &amp;mut query {<br>        let alive = board.squares[usize::from(grid_loc.column)][usize::from(grid_loc.row)];<br>        if alive {<br>            *color = Color::BLACK.into();<br>        } else {<br>            *color = Color::WHITE.into();<br>        }<br>    }<br>}<br><br>fn get_alive_neighbor_counts(board: &amp;Board) -&gt; Vec&lt;Vec&lt;usize&gt;&gt; {<br>    let height = usize::from(board.squares_high);<br>    let width = usize::from(board.squares_wide);<br>    let mut neighbor_counts = vec![vec![0; height]; width];<br>    for (c, row) in neighbor_counts.iter_mut().enumerate() {<br>        for (r, item) in  row.iter_mut().enumerate() {<br>            let mut neighbors = 0;<br>            //Top<br>            if r &gt; 0 {<br>                //T/L<br>                if c &gt; 0 &amp;&amp; board.squares[c-1][r-1] {<br>                    neighbors += 1;<br>                }<br>                //T/C<br>                if board.squares[c][r-1] {<br>                    neighbors += 1;<br>                }<br>                //T/R<br>                if c+1 &lt; width &amp;&amp; board.squares[c+1][r-1] {<br>                    neighbors += 1;<br>                }<br>            }<br>            //Left<br>            if c &gt; 0 &amp;&amp; board.squares[c-1][r] {<br>                neighbors += 1;<br>            }<br>            //Right<br>            if c+1 &lt; width &amp;&amp; board.squares[c+1][r] {<br>                neighbors += 1;<br>            }<br>            //Bottom<br>            if r+1 &lt; height {<br>                //B/L<br>                if c &gt; 0 &amp;&amp; board.squares[c-1][r+1] {<br>                    neighbors += 1;<br>                }<br>                //B/C<br>                if board.squares[c][r+1] {<br>                    neighbors += 1;<br>                }<br>                //B/R<br>                if c+1 &lt; width &amp;&amp; board.squares[c+1][r+1] {<br>                    neighbors += 1;<br>                }<br>            }<br>            *item = neighbors;<br>        }<br>    }<br>    neighbor_counts<br>}</pre><p>Now let’s see this bad-boy in action!</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/796/1*cMR4gik6lfSvNfUlaobTfQ.gif" /></figure><p>git commit -a -m “Add status bar with iterations, gamestate, and alive square count.”</p><h3>Event Triggering</h3><p>I added some counters on our systems to show how often an iteration ticks against the number of draw calls we execute….</p><pre>Draw count:225 iterations:9<br>Draw count:251 iterations:10<br>Draw count:277 iterations:11<br>Draw count:303 iterations:12</pre><p>Whoa, this means for every iteration we execute, we have drawn the board about <strong><em>25</em></strong> times! <strong>Most </strong>of these will be draws that were already present, so wouldn’t it be nice if we only drew the board when we need to??</p><p>The naive approach might be to only do draw_board with the FixedUpdate schedule after we call update_board on, but there are a few issues with that approach:</p><ol><li>update_board only executes when the game is running, so if we were paused, we would only see the results of mouse clicks after the game is resumed.</li><li>Due to the fixed update nature of update_board, our clicks to the screen will be delayed until up to 1/2 sec after we click. This would make the user-input feel sluggish.</li></ol><p>Luckily Bevy includes an Event feature specifically for this — We’ll add various event types to represent which areas need to be redrawn, then we can fire off a redraw event from the mouse, keyboard, or fixed rate update_board functions.</p><p>Events in bevy are sent with an <a href="https://docs.rs/bevy/latest/bevy/prelude/struct.EventWriter.html">EventWriter </a>and read via… you guessed it, an <a href="https://docs.rs/bevy/latest/bevy/prelude/struct.EventReader.html">EventReader</a>! The events can be sent from any system and are passed into the system functions like other parameters once registered to the app.</p><p>A Bevy event can contain custom data, but for our use, we just want them to be a signal to execute some work. For this, we’ll add some new structs with the Event &amp; Default traits derived.</p><pre>//main.rs<br>// below GridLocation<br>#[derive(Event, Default)]<br>struct BoardNeedsUpdateEvent;<br><br>#[derive(Event, Default)]<br>struct BoardNeedsDrawingEvent;<br><br>#[derive(Event, Default)]<br>struct StatusBarNeedsDrawingEvent;</pre><p>These three events will be fired when the board needs to be updated (like on a fixed time click), when the board needs to be redrawn in response to a change, and when the status bar needs an update. We could probably merge the board draw event with the status bar draw event, but it doesn’t hurt much to keep ‘em separate.</p><p>Now we will add a new game_tick_timer function to execute on a fixed time schedule (like update_board previously).</p><pre>//main.rs<br>// before button_system<br>fn game_tick_timer(mut game_board_update_needed: EventWriter&lt;BoardNeedsUpdateEvent&gt;) {<br>    game_board_update_needed.send_default();<br>}</pre><p>Now that we have this new function, let’s change it to fire on the fixed schedule instead of update_board. We’ll also move update_board to execute on the update schedule so we can pick up events in the same cycle as they are fired off. We also need to add the events in a similar fashion as the resources.</p><pre>//main.rs<br>// main() function new App initialize block:<br>     App::new()<br>        .add_plugins(<br>            DefaultPlugins.set(WindowPlugin {<br>                primary_window: Some(Window {<br>                    title: &quot;Conway&#39;s Game of Life&quot;.into(),<br>                    resolution: (window_width, window_height).into(),<br>                    ..default()<br>                }),<br>                ..default()<br>            })<br>        )<br>        .insert_resource(board)<br>        .insert_resource(game_metadata)<br>        .insert_resource(Time::&lt;Fixed&gt;::from_seconds(UPDATE_RATE_SEC))<br>        .add_event::&lt;BoardNeedsUpdateEvent&gt;()<br>        .add_event::&lt;BoardNeedsDrawingEvent&gt;()<br>        .add_event::&lt;StatusBarNeedsDrawingEvent&gt;()<br>        .add_state::&lt;GameState&gt;()<br>        .add_systems(FixedUpdate, game_tick_timer.run_if(in_state(GameState::Running)))<br>        .add_systems(Startup, initial_setup)<br>        .add_systems(Update, (button_system, keyboard_system, update_board, draw_board, status_bar_text_update).chain())<br>        .run();<br></pre><p>This is where the strict system ordering comes in very handy as we can fire off an event in response to a mouse click or keyboard press and pick up that event in the later functions that execute on the same game cycle.</p><p>Now we’ll update our keyboard and mouse systems to fire off some events on the appropriate changes. Some updates require a board redraw, while others need to update the status bar.</p><p>Update the keyboard system to take all three event writers in and fire off the events when the appropriate key is pressed. We also prune out the status bar update from being directly in the keyboard system to have better duty separation.</p><pre>//main.rs<br>//Update button_system<br>#[allow(clippy::type_complexity)]<br>fn button_system(mut interaction_query: Query&lt;<br>    (<br>        &amp;Interaction,<br>        &amp;GridLocation,<br>    ),<br>    (Changed&lt;Interaction&gt;, With&lt;Button&gt;),<br>&gt;, mut board: ResMut&lt;Board&gt;, mut board_needs_drawing: EventWriter&lt;BoardNeedsDrawingEvent&gt;,<br>    mut status_bar_needs_update: EventWriter&lt;StatusBarNeedsDrawingEvent&gt;) {<br>    for (interaction, grid_loc) in &amp;mut interaction_query {<br>        match *interaction {<br>            Interaction::Pressed =&gt; {<br>                let r = grid_loc.row;<br>                let c = grid_loc.column;<br>                //Get the game state.<br>                let cur = board.squares[c][r];<br>                println!(&quot;Button pressed at ({c},{r}) -- Currently:{cur}&quot;);<br>                if cur {<br>                    board.alive_squares -= 1;<br>                } else {<br>                    board.alive_squares += 1;<br>                }<br>                board.squares[c][r] = !cur;<br>                board_needs_drawing.send_default();<br>                status_bar_needs_update.send_default();<br>            },<br>            Interaction::Hovered | Interaction::None =&gt; {},<br>        }<br>    }<br>}<br><br>#[allow(clippy::needless_pass_by_value)]<br>fn keyboard_system(keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;, game_state: Res&lt;State&lt;GameState&gt;&gt;, mut next_game_state: ResMut&lt;NextState&lt;GameState&gt;&gt;,<br>    mut board: ResMut&lt;Board&gt;, mut board_needs_drawing_events: EventWriter&lt;BoardNeedsDrawingEvent&gt;,<br>    mut board_update_events: EventWriter&lt;BoardNeedsUpdateEvent&gt;, mut status_bar_needs_redraw: EventWriter&lt;StatusBarNeedsDrawingEvent&gt;) {<br>    if keyboard_input.just_pressed(KeyCode::Space) {<br>        match game_state.to_owned() {<br>            GameState::Running =&gt; {<br>                next_game_state.set(GameState::Paused);<br>            },<br>            GameState::Paused =&gt; {<br>                next_game_state.set(GameState::Running);<br>            },<br>        }<br>        status_bar_needs_redraw.send_default();<br>    }<br>    if keyboard_input.just_pressed(KeyCode::C) {<br>        println!(&quot;Clear&quot;);<br>        for c in 0..board.squares_wide {<br>            for r in 0..board.squares_high {<br>                board.squares[c][r] = false;<br>            }<br>        }<br>        board.alive_squares = 0;<br>        board_needs_drawing_events.send_default();<br>        status_bar_needs_redraw.send_default();<br>    }<br>    if keyboard_input.just_pressed(KeyCode::N) {<br>        println!(&quot;Next&quot;);<br>        //Send an update to update the board state, including the iterations.<br>        if game_state.to_owned() == GameState::Paused {<br>            board_update_events.send_default();<br>        } else {<br>            println!(&quot;Next disabled when not paused.&quot;);<br>        } <br>    }<br>}</pre><p>Keen readers will notice I snuck a new function into our program — When paused, we can now hit <strong>n</strong> to move to the next board state! This addition was super easy due to the event system, and is core to why we created the new game_tick_timer function instead of leaving update_board on a schedule.</p><p>Now, we’ll gate our first function on the presence of an event in the queue. We return early if we don’t have any event available to process.</p><p>We also need to update our status bar updater to also update the pause/resume message based on the <em>next </em>game state, as we had a minor bug in the prior version as the update lagged by one frame.</p><pre>//main.rs<br>// Change GameState to be the next one, gate the execution of the function on an event,<br>// Change the Pause text to also include &#39;N&#39; key instructions.<br>#[allow(clippy::type_complexity, clippy::needless_pass_by_value)]<br>fn status_bar_text_update(mut text_params: ParamSet&lt;(Query&lt;&amp;mut Text, With&lt;GameStateText&gt;&gt;, Query&lt;&amp;mut Text, With&lt;IterationText&gt;&gt;)&gt;, board: Res&lt;Board&gt;,<br>    metadata: Res&lt;GameMetadata&gt;, next_game_state: Res&lt;NextState&lt;GameState&gt;&gt;, mut status_bar_needs_redraw: EventReader&lt;StatusBarNeedsDrawingEvent&gt;) {<br>    if status_bar_needs_redraw.is_empty() {<br>        return;<br>    }<br>    status_bar_needs_redraw.clear();<br>    <br>    let game_state = next_game_state.0.as_ref().unwrap_or(&amp;GameState::Running);<br>    let mut game_state_query = text_params.p0();<br>    match game_state {<br>        GameState::Running =&gt; {<br>            game_state_query.single_mut().sections[0].value = &quot;Running: [space] to pause, [c] to clear.&quot;.to_string();<br>        },<br>        GameState::Paused =&gt; {<br>            game_state_query.single_mut().sections[0].value = &quot;Paused: [space] to resume, [c] to clear, [n] for next.&quot;.to_string();<br>        },<br>    }<br>    let mut iter_state_query = text_params.p1();<br>    let new_text = format!(&quot;Iter:{}; Alive:{}&quot;, metadata.iterations, board.alive_squares);<br>    iter_state_query.single_mut().sections[0].value = new_text;<br>}</pre><p>Now we’ll gate update_board on the event reader, but also pass in the event writers for both draw event types. <em>As a side note: </em>We should have all event writers generally execute before the event reads may check for the events.</p><pre>//main.rs<br>fn update_board(mut query: Query&lt;&amp;GridLocation&gt;, mut board: ResMut&lt;Board&gt;, mut metadata: ResMut&lt;GameMetadata&gt;,<br>    mut board_update_events: EventReader&lt;BoardNeedsUpdateEvent&gt;, mut board_needs_draw_event: EventWriter&lt;BoardNeedsDrawingEvent&gt;,<br>    mut status_bar_needs_update: EventWriter&lt;StatusBarNeedsDrawingEvent&gt;) {<br>    if board_update_events.is_empty() {<br>        return;<br>    }<br>    board_update_events.clear();<br>    //&lt;...&gt;<br>    //After we increment metadata, fire off two events.<br>    board_needs_draw_event.send_default();<br>    status_bar_needs_update.send_default();<br>}</pre><p>We also need to gate draw_board.</p><pre>//main.rs<br>// Update to draw_board to do work on event presence.<br>#[allow(clippy::needless_pass_by_value)]<br>fn draw_board(mut query: Query&lt;(&amp;mut BackgroundColor, &amp;GridLocation)&gt;, board: Res&lt;Board&gt;, mut board_needs_draw_events: EventReader&lt;BoardNeedsDrawingEvent&gt;) {<br>    if board_needs_draw_events.is_empty() {<br>        return;<br>    }<br>    board_needs_draw_events.clear();<br>//</pre><p>(Full main.rs after the next section)</p><p>Fantastic, we now have an event system that will only execute our more expensive operations like a redraw when updates are necessary.</p><p>Commitments are useful! git commit -a -m “Add event based board updates, board drawing, and status bar updates.”</p><h3>Kick it up to 11 (Home stretch now)</h3><p>Ok, so far we’ve had a pretty small 20x20 game board — let’s kick it up a notch! We’ll reduce the square size and bump the board to 100x100.</p><pre>//main.rs<br>//Update the TILE_SIZE<br>const TILE_SIZE: u16 = 8;<br><br>//Update the game board size in main()<br>let cols = 100;<br>let rows = 100;</pre><p>When you execute cargo run you may notice the game running a bit slower… And on modern PCs that seems odd… it’s only 10,000 squares to run a sim on… it certainly should be able to handle it.</p><p>The primary reason is Bevy runs <strong><em>very </em></strong>slowly when it’s debug variant is built, so we want to add some optimization for it (and other dependencies).</p><p>Add this to the bottom of your Cargo.toml file and we should be back to a 1/2 second tick time.</p><pre>//Cargo.toml<br>//After [dependencies] block.<br><br># Enable max optimizations for dependencies, but not for our code:<br>[profile.dev.package.&quot;*&quot;]<br>opt-level = 3</pre><p>Now, run a cargo clean and a cargo build you may notice some steam coming from your PC while it compiles and optimizes the bevy dependencies. This was the first time outside of a AAA game I had heard my CPU fan kick into high gear.</p><p>Now if we run cargo run it has some very interesting patterns with the larger board!</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/796/1*-IMUqMNqwN849cO6_jimHg.gif" /></figure><p>And now, the final full main.rs</p><pre>//main.rs<br>#![warn(clippy::pedantic)]<br><br>use bevy::prelude::*;<br><br>//Default for the tile sizes.<br>const TILE_SIZE: u16 = 8;<br>const STATUS_BAR_PX: f32 = 40.0;<br>const UPDATE_RATE_SEC: f64 = 0.1;<br><br>#[derive(Debug, Default, Clone, Eq, PartialEq, Hash, States)]<br>enum GameState {<br>    #[default]<br>    Running,<br>    Paused,<br>}<br><br>#[derive(Resource)]<br>struct Board {<br>    squares_wide: u16,<br>    squares_high: u16,<br>    squares: Vec&lt;Vec&lt;bool&gt;&gt;,<br>    alive_squares: usize,<br>}<br><br>#[derive(Resource, Default)]<br>struct GameMetadata {<br>    iterations: usize<br>}<br><br>#[derive(Component)]<br>struct IterationText;<br><br>#[derive(Component)]<br>struct GameStateText;<br><br>#[derive(Component, Debug)]<br>struct GridLocation {<br>    row: u16,<br>    column: u16<br>}<br><br>#[derive(Event, Default)]<br>struct BoardNeedsUpdateEvent;<br><br>#[derive(Event, Default)]<br>struct BoardNeedsDrawingEvent;<br><br>#[derive(Event, Default)]<br>struct StatusBarNeedsDrawingEvent;<br><br>fn main() {<br>    println!(&quot;Bevy app starting!&quot;);<br>    let cols = 100;<br>    let rows = 100;<br>    // Create a 2d vector where every other square is on or off.<br>    // This is equivalent to a nested for loop over cols then row elements.<br>    let board_state = (0..cols).map(|col| <br>        (0..rows).map(|row| <br>            (col + row) % 2 == 0)<br>            .collect())<br>    .collect();<br>    let board = Board {squares_wide: cols, squares_high: rows, squares: board_state, alive_squares: usize::from(cols) * usize::from(rows) / 2};<br>    let game_metadata = GameMetadata::default();<br>    let window_width = f32::from(TILE_SIZE * board.squares_wide);<br>    let window_height =  f32::from(TILE_SIZE * board.squares_high) + STATUS_BAR_PX;<br>    App::new()<br>        .add_plugins(<br>            DefaultPlugins.set(WindowPlugin {<br>                primary_window: Some(Window {<br>                    title: &quot;Conway&#39;s Game of Life&quot;.into(),<br>                    resolution: (window_width, window_height).into(),<br>                    ..default()<br>                }),<br>                ..default()<br>            })<br>        )<br>        .insert_resource(board)<br>        .insert_resource(game_metadata)<br>        .insert_resource(Time::&lt;Fixed&gt;::from_seconds(UPDATE_RATE_SEC))<br>        .add_event::&lt;BoardNeedsUpdateEvent&gt;()<br>        .add_event::&lt;BoardNeedsDrawingEvent&gt;()<br>        .add_event::&lt;StatusBarNeedsDrawingEvent&gt;()<br>        .add_state::&lt;GameState&gt;()<br>        .add_systems(FixedUpdate, game_tick_timer.run_if(in_state(GameState::Running)))<br>        .add_systems(Startup, initial_setup)<br>        .add_systems(Update, (button_system, keyboard_system, update_board, draw_board, status_bar_text_update).chain())<br>        .run();<br>}<br><br>#[allow(clippy::needless_pass_by_value)]<br>fn initial_setup(mut commands: Commands, board: Res&lt;Board&gt;, metadata: ResMut&lt;GameMetadata&gt;) {<br>    commands.spawn(Camera2dBundle::default());<br>    //Button style<br>    let button_style = Style {<br>        display: Display::Grid,<br>        justify_content: JustifyContent::Center,<br>        align_items: AlignItems::Center,<br>        ..default()<br>    };<br>    //Draw the grid layout!<br>    commands<br>        .spawn(NodeBundle {<br>            style: Style {<br>                //Create a grid layout,<br>                display: Display::Grid,<br>                width: Val::Percent(100.0),<br>                height: Val::Percent(100.0),<br>                grid_template_columns: vec![<br>                    GridTrack::auto()<br>                ],<br>                //Top Row will take up all the space after the bottom row is complete.<br>                grid_template_rows: vec![<br>                    GridTrack::flex(1.0), GridTrack::px(STATUS_BAR_PX)<br>                ],<br>                ..default()<br>            },<br>            background_color: BackgroundColor(Color::WHITE),<br>            ..default()<br>        })<br>        .with_children(|builder| {<br>            //Game Area<br>            builder.spawn(NodeBundle {<br>                style: Style {<br>                    //Create a grid layout,<br>                    display: Display::Grid,<br>                    width: Val::Percent(100.0),<br>                    height: Val::Percent(100.0),<br>                    grid_template_columns: vec![<br>                        GridTrack::auto(); usize::from(board.squares_wide)<br>                    ],<br>                    grid_template_rows: vec![<br>                        GridTrack::auto(); usize::from(board.squares_high)<br>                    ],<br>                    ..default()<br>                },<br>                background_color: BackgroundColor(Color::WHITE),<br>                ..default()<br>            })<br>            .with_children(|game_area_builder| {<br>                //Every other will be black or white!<br>                for c in 0..board.squares_wide {<br>                    for r in 0..board.squares_high {<br>                        //Set the color based on the board state.<br>                        let color = if board.squares[usize::from(c)][usize::from(r)] {<br>                            Color::BLACK<br>                        } else {<br>                            Color::WHITE<br>                        };<br>                        let grid_loc = GridLocation {column: c, row: r};<br>                        game_area_builder.spawn(<br>                            (ButtonBundle {<br>                                style: button_style.clone(),<br>                                background_color: BackgroundColor(color),<br>                                ..default()<br>                            }, grid_loc)<br>                        );<br>                    }<br>                }<br>            });<br>            //Status Tray<br>            builder.spawn(NodeBundle {<br>                style: Style {<br>                    display: Display::Grid,<br>                    padding: UiRect::all(Val::Px(6.0)),<br>                    grid_template_rows: vec![<br>                        GridTrack::auto()<br>                    ],<br>                    //Left slot, right slot.<br>                    grid_template_columns: vec![<br>                        GridTrack::auto(), GridTrack::auto()<br>                    ],<br>                    ..default()<br>                },<br>                ..default()<br>            })<br>            .with_children(|tray_builder| {<br>                tray_builder.spawn((TextBundle::from_section(<br>                    &quot;Running: [space] to pause, [c] to clear.&quot;,<br>                    TextStyle {<br>                        font: Handle::default(),<br>                        font_size: 20.0,<br>                        color: Color::BLACK,<br>                    },<br>                ), GameStateText));<br>                tray_builder.spawn((TextBundle::from_section(<br>                    format!(&quot;Iter:{}; Alive:{}&quot;, metadata.iterations, board.alive_squares),<br>                    TextStyle {<br>                        font: Handle::default(),<br>                        font_size: 20.0,<br>                        color: Color::BLACK,<br>                    },<br>                ).with_text_alignment(TextAlignment::Right), IterationText));<br>            });<br>        });<br>}<br><br>fn game_tick_timer(mut game_board_update_needed: EventWriter&lt;BoardNeedsUpdateEvent&gt;) {<br>    game_board_update_needed.send_default();<br>}<br><br>#[allow(clippy::type_complexity)]<br>fn button_system(mut interaction_query: Query&lt;<br>    (<br>        &amp;Interaction,<br>        &amp;GridLocation,<br>    ),<br>    (Changed&lt;Interaction&gt;, With&lt;Button&gt;),<br>&gt;, mut board: ResMut&lt;Board&gt;, mut board_needs_drawing: EventWriter&lt;BoardNeedsDrawingEvent&gt;,<br>    mut status_bar_needs_update: EventWriter&lt;StatusBarNeedsDrawingEvent&gt;) {<br>    for (interaction, grid_loc) in &amp;mut interaction_query {<br>        match *interaction {<br>            Interaction::Pressed =&gt; {<br>                let r = usize::from(grid_loc.row);<br>                let c = usize::from(grid_loc.column);<br>                //Get the game state.<br>                let cur = board.squares[c][r];<br>                if cur {<br>                    board.alive_squares -= 1;<br>                } else {<br>                    board.alive_squares += 1;<br>                }<br>                println!(&quot;Button pressed at ({c},{r}) -- Currently:{cur}&quot;);<br>                board.squares[c][r] = !cur;<br>                board_needs_drawing.send_default();<br>                status_bar_needs_update.send_default();<br>            },<br>            Interaction::Hovered | Interaction::None =&gt; {},<br>        }<br>    }<br>}<br><br>#[allow(clippy::needless_pass_by_value)]<br>fn keyboard_system(keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;, game_state: Res&lt;State&lt;GameState&gt;&gt;, mut next_game_state: ResMut&lt;NextState&lt;GameState&gt;&gt;, <br>    mut board: ResMut&lt;Board&gt;, mut board_needs_drawing_events: EventWriter&lt;BoardNeedsDrawingEvent&gt;,<br>    mut board_update_events: EventWriter&lt;BoardNeedsUpdateEvent&gt;, mut status_bar_needs_redraw: EventWriter&lt;StatusBarNeedsDrawingEvent&gt;) {<br>    if keyboard_input.just_pressed(KeyCode::Space) {<br>        match game_state.to_owned() {<br>            GameState::Running =&gt; {<br>                println!(&quot;Pausing&quot;);<br>                next_game_state.set(GameState::Paused);<br>            },<br>            GameState::Paused =&gt; {<br>                println!(&quot;Running&quot;);<br>                next_game_state.set(GameState::Running);<br>            },<br>        }<br>        status_bar_needs_redraw.send_default();<br>    }<br>    if keyboard_input.just_pressed(KeyCode::C) {<br>        println!(&quot;Clear&quot;);<br>        for c in 0..usize::from(board.squares_wide) {<br>            for r in 0..usize::from(board.squares_high) {<br>                board.squares[c][r] = false;<br>            }<br>        }<br>        board.alive_squares = 0;<br>        board_needs_drawing_events.send_default();<br>        status_bar_needs_redraw.send_default();<br>    }<br>    if keyboard_input.just_pressed(KeyCode::N) {<br>        println!(&quot;Next&quot;);<br>        //Send an update to update the board state, including the iterations.<br>        if game_state.to_owned() == GameState::Paused {<br>            board_update_events.send_default();<br>        } else {<br>            println!(&quot;Next disabled when not paused.&quot;);<br>        } <br>    }<br>}<br><br>#[allow(clippy::type_complexity, clippy::needless_pass_by_value)]<br>fn status_bar_text_update(mut text_params: ParamSet&lt;(Query&lt;&amp;mut Text, With&lt;GameStateText&gt;&gt;, Query&lt;&amp;mut Text, With&lt;IterationText&gt;&gt;)&gt;, board: Res&lt;Board&gt;,<br>    metadata: Res&lt;GameMetadata&gt;, next_game_state: Res&lt;NextState&lt;GameState&gt;&gt;, mut status_bar_needs_redraw: EventReader&lt;StatusBarNeedsDrawingEvent&gt;) {<br>    if status_bar_needs_redraw.is_empty() {<br>        return;<br>    }<br>    status_bar_needs_redraw.clear();<br>    <br>    let game_state = next_game_state.0.as_ref().unwrap_or(&amp;GameState::Running);<br>    let mut game_state_query = text_params.p0();<br>    match game_state {<br>        GameState::Running =&gt; {<br>            game_state_query.single_mut().sections[0].value = &quot;Running: [space] to pause, [c] to clear.&quot;.to_string();<br>        },<br>        GameState::Paused =&gt; {<br>            game_state_query.single_mut().sections[0].value = &quot;Paused: [space] to resume, [c] to clear, [n] for next.&quot;.to_string();<br>        },<br>    }<br>    let mut iter_state_query = text_params.p1();<br>    let new_text = format!(&quot;Iter:{}; Alive:{}&quot;, metadata.iterations, board.alive_squares);<br>    iter_state_query.single_mut().sections[0].value = new_text;<br>}<br><br><br><br>fn update_board(mut query: Query&lt;&amp;GridLocation&gt;, mut board: ResMut&lt;Board&gt;, mut metadata: ResMut&lt;GameMetadata&gt;,<br>    mut board_update_events: EventReader&lt;BoardNeedsUpdateEvent&gt;, mut board_needs_draw_event: EventWriter&lt;BoardNeedsDrawingEvent&gt;,<br>    mut status_bar_needs_update: EventWriter&lt;StatusBarNeedsDrawingEvent&gt;) {<br>    //Fetch the neighbor counts.<br>    if board_update_events.is_empty() {<br>        return;<br>    }<br>    board_update_events.clear();<br>    let neighbor_counts = get_alive_neighbor_counts(board.as_ref());<br>    let mut alive_count = 0;<br>    for grid_loc in &amp;mut query {<br>        let c = usize::from(grid_loc.column);<br>        let r = usize::from(grid_loc.row);<br>        let cur = board.squares[c][r];<br>        let n = neighbor_counts[c][r];<br>        let mut new_state = cur;<br>        if cur {<br>            // Live cell<br>            //fewer than two live neighbours dies, as if by underpopulation.<br>            if n &lt; 2 {<br>                //Underpop<br>                new_state = false;<br>            }<br>            //two or three live neighbours lives on to the next generation.<br>            if n == 2 || n == 3 {<br>                //We live!<br>                new_state = true;<br>            }<br>            //more than three live neighbours dies, as if by overpopulation.<br>            if n &gt; 3 {<br>                //Overpop<br>                new_state = false;<br>            }<br>        } else {<br>            // Dead Cell<br>            //exactly three live neighbours becomes a live cell, as if by reproduction.<br>            if n == 3 {<br>                //breeeed<br>                new_state = true;<br>            }<br>        }<br>        if new_state {<br>            alive_count += 1;<br>        }<br>        //Update the data<br>        board.squares[c][r] = new_state;<br>    }<br>    board.alive_squares = alive_count;<br>    metadata.iterations += 1;<br>    board_needs_draw_event.send_default();<br>    status_bar_needs_update.send_default();<br>}<br><br>#[allow(clippy::needless_pass_by_value)]<br>fn draw_board(mut query: Query&lt;(&amp;mut BackgroundColor, &amp;GridLocation)&gt;, board: Res&lt;Board&gt;, mut board_needs_draw_events: EventReader&lt;BoardNeedsDrawingEvent&gt;) {<br>    if board_needs_draw_events.is_empty() {<br>        return;<br>    }<br>    board_needs_draw_events.clear();<br>    for (mut color, grid_loc) in &amp;mut query {<br>        let alive = board.squares[usize::from(grid_loc.column)][usize::from(grid_loc.row)];<br>        if alive {<br>            *color = Color::BLACK.into();<br>        } else {<br>            *color = Color::WHITE.into();<br>        }<br>    }<br>}<br><br>fn get_alive_neighbor_counts(board: &amp;Board) -&gt; Vec&lt;Vec&lt;usize&gt;&gt; {<br>    let height = usize::from(board.squares_high);<br>    let width = usize::from(board.squares_wide);<br>    let mut neighbor_counts = vec![vec![0; height]; width];<br>    for (c, row) in neighbor_counts.iter_mut().enumerate() {<br>        for (r, item) in  row.iter_mut().enumerate() {<br>            let mut neighbors = 0;<br>            //Top<br>            if r &gt; 0 {<br>                //T/L<br>                if c &gt; 0 &amp;&amp; board.squares[c-1][r-1] {<br>                    neighbors += 1;<br>                }<br>                //T/C<br>                if board.squares[c][r-1] {<br>                    neighbors += 1;<br>                }<br>                //T/R<br>                if c+1 &lt; width &amp;&amp; board.squares[c+1][r-1] {<br>                    neighbors += 1;<br>                }<br>            }<br>            //Left<br>            if c &gt; 0 &amp;&amp; board.squares[c-1][r] {<br>                neighbors += 1;<br>            }<br>            //Right<br>            if c+1 &lt; width &amp;&amp; board.squares[c+1][r] {<br>                neighbors += 1;<br>            }<br>            //Bottom<br>            if r+1 &lt; height {<br>                //B/L<br>                if c &gt; 0 &amp;&amp; board.squares[c-1][r+1] {<br>                    neighbors += 1;<br>                }<br>                //B/C<br>                if board.squares[c][r+1] {<br>                    neighbors += 1;<br>                }<br>                //B/R<br>                if c+1 &lt; width &amp;&amp; board.squares[c+1][r+1] {<br>                    neighbors += 1;<br>                }<br>            }<br>            *item = neighbors;<br>        }<br>    }<br>    neighbor_counts<br>}</pre><p>Last reminder — commit it for good measure!</p><p>git commit -a -m “Make board 100x100 and optimize dependencies.”</p><h3>Wrap it up!</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/400/1*FhrjoJmcVIV7w4Spn6vA_w.gif" /></figure><p>That wraps up our Bevy game of life tutorial! Thank you for reading, and I hope you had fun running through it with me! Please feel free to reach out if there are any areas that need to be clarified or corrected.</p><p>For additional fun there are a few things I didn’t add to the game that would be nice features.</p><ul><li>Add the ability to go back in history up to N iterations via a ‘previous’ keypress.</li><li>Game menu with configurable items like board size, game speed, game color scheme, etc.</li><li>The ability to resize the game’s window up and down including automatic tile scaling.</li><li>Add ability to ‘load’ a csv of various board states to try out different scenarios.</li><li>Add a ‘clear and randomize’ option as a keypress that restarts the sim with the squares in a random on/off configuration.</li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c7f7e5322640" width="1" height="1" alt="">
